<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>thread on moonsn&#39;s profile</title>
    <link>https://moonsn.com/tags/thread/</link>
    <description>Recent content in thread on moonsn&#39;s profile</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Wed, 04 Nov 2015 15:10:00 +0800</lastBuildDate><atom:link href="https://moonsn.com/tags/thread/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Thread</title>
      <link>https://moonsn.com/post/thread/</link>
      <pubDate>Wed, 04 Nov 2015 15:10:00 +0800</pubDate>
      
      <guid>https://moonsn.com/post/thread/</guid>
      <description>前段时间看了golang.并行的模块停下来了，正好这个学期上操作系统，而且前段时间的五子棋设计的时候需要网络通信。多线程就成了必要的东西的了。是时候看看线程了。
 在没有设计多线程之前，我们的程序是step by step的！
大程序往往会由许许多多的小程序组成，例如，Web服务器需要处理从浏览器发来的请求，并回复HTML页面。每个请求就像一个小程序。 web服务器能同时处理多个请求，这就需要并行的技术了。
在java中要使一个类的几个示例多线程运行，则类需要继承自Runnable类。然后用 Thread类来创建进程。(当然还有其他的方式).
在Go中，用goroutines 和 channels来支持并行.
Goroutines 对于goroutines:
 A goroutine is a function that is capable of running concurrently with other functions.
 要新建一个goroutine:
package main import &amp;quot;fmt&amp;quot; import &amp;quot;time&amp;quot; func f(n int) { for i := 0; i &amp;lt; 10; i++ { fmt.Println(n, &amp;quot;:&amp;quot;, i) time.Sleep(time.Millisecond * 1000) } } func main() { go f(0) var input string fmt.Scanln(&amp;amp;input) } 上面的代码中有两个goroutine。第一个是个隐式的:main函数本身。第二个是我们用go f(0)创建的。 正常情况下，函数调用会执行完返回再进入下一行，但是有了goroutine，会马上执行下一行，不用等到函数返回。</description>
    </item>
    
  </channel>
</rss>
