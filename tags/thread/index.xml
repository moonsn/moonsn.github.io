<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Thread on moonsn&#39;s profile</title>
    <link>http://localhost:1313/tags/thread/</link>
    <description>Recent content in Thread on moonsn&#39;s profile</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Wed, 04 Nov 2015 15:10:00 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/thread/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Thread</title>
      <link>http://localhost:1313/post/thread/</link>
      <pubDate>Wed, 04 Nov 2015 15:10:00 +0800</pubDate>
      
      <guid>http://localhost:1313/post/thread/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;前段时间看了golang.并行的模块停下来了，正好这个学期上操作系统，而且前段时间的五子棋设计的时候需要网络通信。多线程就成了必要的东西的了。是时候看看线程了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在没有设计多线程之前，我们的程序是step by step的！&lt;/p&gt;

&lt;p&gt;大程序往往会由许许多多的小程序组成，例如，Web服务器需要处理从浏览器发来的请求，并回复HTML页面。每个请求就像一个小程序。
web服务器能同时处理多个请求，这就需要并行的技术了。&lt;/p&gt;

&lt;p&gt;在java中要使一个类的几个示例多线程运行，则类需要继承自&lt;code&gt;Runnable&lt;/code&gt;类。然后用 &lt;code&gt;Thread&lt;/code&gt;类来创建进程。(当然还有其他的方式).&lt;/p&gt;

&lt;p&gt;在Go中，用&lt;code&gt;goroutines&lt;/code&gt; 和 &lt;code&gt;channels&lt;/code&gt;来支持并行.&lt;/p&gt;

&lt;h2 id=&#34;goroutines:8f9474acbe8eccfc75abfaabcbdf5ffa&#34;&gt;Goroutines&lt;/h2&gt;

&lt;p&gt;对于&lt;code&gt;goroutines&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A goroutine is a function that is capable of running concurrently with other functions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;要新建一个&lt;code&gt;goroutine&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;
import &amp;quot;time&amp;quot;

func f(n int) {
	for i := 0; i &amp;lt; 10; i++ {
		fmt.Println(n, &amp;quot;:&amp;quot;, i)
		time.Sleep(time.Millisecond * 1000)
	}
}

func main() {
	go f(0)
	var input string
	fmt.Scanln(&amp;amp;input)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码中有两个&lt;code&gt;goroutine&lt;/code&gt;。第一个是个隐式的:&lt;code&gt;main&lt;/code&gt;函数本身。第二个是我们用&lt;code&gt;go f(0)&lt;/code&gt;创建的。
正常情况下，函数调用会执行完返回再进入下一行，但是有了&lt;code&gt;goroutine&lt;/code&gt;，会马上执行下一行，不用等到函数返回。&lt;/p&gt;

&lt;p&gt;这么看来，go语言的&lt;code&gt;goroutine&lt;/code&gt;比java中的轻量了许多。也方便了不少。&lt;/p&gt;

&lt;h2 id=&#34;channels:8f9474acbe8eccfc75abfaabcbdf5ffa&#34;&gt;channels&lt;/h2&gt;

&lt;p&gt;对于&lt;code&gt;channels&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Channels provide a way for two goroutines to communicate with one another and synchronize
their execution.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;time&amp;quot;
)

func pinger(c chan string) {
  for i := 0; ; i++ {
    c &amp;lt;- &amp;quot;ping&amp;quot;
  }
}

func printer(c chan string) {
  for {
    msg := &amp;lt;- c
    fmt.Println(msg)
    time.Sleep(time.Second * 1)
  }
}

func main() {
  var c chan string = make(chan string)

  go pinger(c)
  go printer(c)

  var input string
  fmt.Scanln(&amp;amp;input)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;channal的声明就不说了，我们可以当c时一个容器，这里是string容器。
printer会输出c里的内容,而pinger书不断往容器里放入&amp;rdquo;ping&amp;rdquo;。当容器是空的时候，printer就会阻塞了.&lt;/p&gt;

&lt;p&gt;对了,channel是可以有buffer大小的:&lt;code&gt;make(chan int , 3)&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;select:8f9474acbe8eccfc75abfaabcbdf5ffa&#34;&gt;select&lt;/h2&gt;

&lt;p&gt;这是&lt;code&gt;channel&lt;/code&gt;的switch。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
  c1 := make(chan string)
  c2 := make(chan string)

  go func() {
    for {
      c1 &amp;lt;- &amp;quot;from 1&amp;quot;
      time.Sleep(time.Second * 2)
    }
  }()

  go func() {
    for {
      c2 &amp;lt;- &amp;quot;from 2&amp;quot;
      time.Sleep(time.Second * 3)
    }
  }()

  go func() {
    for {
      select {
      case msg1 := &amp;lt;- c1:
        fmt.Println(msg1)
      case msg2 := &amp;lt;- c2:
        fmt.Println(msg2)
      }
    }
  }()

  var input string
  fmt.Scanln(&amp;amp;input)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>