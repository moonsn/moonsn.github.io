<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>0424结题报告 | moonsn</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="A poj1319这是很有意思的一道数学题。按题目要求每行管子之间不能有空隙，因此任意上下两个管子的位置关系只能有两种：正对或60度斜错，其它的角度都会使上一行或下一行的管子间产生空隙。题目还给出管子的直径是一个单位，这样问题就简单多了。那么如果是网格方式排列（即上下正对），那么直接将贮藏箱的长宽取整即为可容纳管子的数量。
如果是交错排列（上下行斜错60度），情况稍有点复杂。为方便描述，我们把箱子">
<meta property="og:type" content="article">
<meta property="og:title" content="0424结题报告">
<meta property="og:url" content="http://moonsn.com/2015/04/24/ACM0424/index.html">
<meta property="og:site_name" content="moonsn">
<meta property="og:description" content="A poj1319这是很有意思的一道数学题。按题目要求每行管子之间不能有空隙，因此任意上下两个管子的位置关系只能有两种：正对或60度斜错，其它的角度都会使上一行或下一行的管子间产生空隙。题目还给出管子的直径是一个单位，这样问题就简单多了。那么如果是网格方式排列（即上下正对），那么直接将贮藏箱的长宽取整即为可容纳管子的数量。
如果是交错排列（上下行斜错60度），情况稍有点复杂。为方便描述，我们把箱子">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/devymex/256255/o_skew.PNG">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/devymex/256255/o_skew1.bmp">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="0424结题报告">
<meta name="twitter:description" content="A poj1319这是很有意思的一道数学题。按题目要求每行管子之间不能有空隙，因此任意上下两个管子的位置关系只能有两种：正对或60度斜错，其它的角度都会使上一行或下一行的管子间产生空隙。题目还给出管子的直径是一个单位，这样问题就简单多了。那么如果是网格方式排列（即上下正对），那么直接将贮藏箱的长宽取整即为可容纳管子的数量。
如果是交错排列（上下行斜错60度），情况稍有点复杂。为方便描述，我们把箱子">
<meta name="twitter:creator" content="@kawaiiushio">
<link rel="publisher" href="u/0/112705918015792136321">
  
    <link rel="alternative" href="/atom.xml" title="moonsn" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
    <meta name="theme-color" content="#ffffff">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
  <style type="text/css">
html {background-color: white}</style>
</head>

<body>
  <div id="container">
    <div id="wrap">
      
  <header id="header" class="small">

  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">moonsn</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">What is the meaning of life, the universe and everything?</a>
        </h2>
      
      <div id="rss-wrap">
      
        <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
      
      
        <a id="nav-github-link" class="nav-icon" href="https://github.com/kawaiiushio" title="Github" target="_blank"></a>
      
      </div>
    </div>
  </div>
  <div id="header-inner" class="">
    <a class="title"><h1>moonsn</h1></a>
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
    </nav>
    <nav id="sub-nav">
      <a id="nav-search-btn" class="nav-icon" title="Search"></a>
    </nav>
    <div id="search-form-wrap">
      <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://moonsn.com"></form>
    </div>
  </div>
  <div class="site-nav">
    <ul>
    
      <li>
        <a href="/">主页</a>
      </li>
    
      <li>
        <a href="/archives">归档</a>
      </li>
    
      <li>
        <a href="/links">小伙伴</a>
      </li>
    
      <li>
        <a href="/about">关于</a>
      </li>
    
    </ul>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-ACM0424" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/24/ACM0424/" class="article-date">
  <time datetime="2015-04-24T13:00:00.000Z" itemprop="datePublished">2015-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      0424结题报告
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="A_poj1319">A poj1319</h2><p>这是很有意思的一道数学题。按题目要求每行管子之间不能有空隙，因此任意上下两个管子的位置关系只能有两种：正对或60度斜错，其它的角度都会使上一行或下一行的管子间产生空隙。题目还给出管子的直径是一个单位，这样问题就简单多了。那么如果是网格方式排列（即上下正对），那么直接将贮藏箱的长宽取整即为可容纳管子的数量。</p>
<p>如果是交错排列（上下行斜错60度），情况稍有点复杂。为方便描述，我们把箱子最底一的一行称为第0行，之上一行为第1行，以此类推。第0行的行高显然为直径，从第1行开始向上，每行的行高都为下面一行的顶到这一行顶的距离。该行高可简单的用勾股定理计算，方法见下图：</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/devymex/256255/o_skew.PNG" alt=""></p>
<p>图中r为半径，d为直径，红色等边三角形的顶点分别为三个管子横截面的圆心。可以看出，上面一行的行高即等于该三角形的高，由此可计算出贮藏箱一共可以放多少行。但列的情况又稍有不同，如下图所示：</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/devymex/256255/o_skew1.bmp" alt=""></p>
<p>如果最底一行在放满管子后，剩下的空间大于半径，那么上面的所有行都可放置相同数量的管子。但如果剩下的空间不足半径，那么奇数行就只能放下的数量就比偶数行少1个。为方便计算，可先按每行相同数量的管子乘以行数，得到所有的管子数量，然后减掉不能放下的奇数行的管子。具体实现方法详见下面代码中的注释。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#include &#60;iostream&#62;&#10;using namespace std;&#10;//&#35745;&#31639;&#20132;&#38169;&#25490;&#21015;&#27861;&#30340;&#25968;&#37327;&#10;int Skew(float x, float y) &#123;&#10;&#160;&#160;&#160;&#160;//fSqrt3_2&#20026;&#24320;&#26041;3&#38500;&#20197;2&#65292;&#34920;&#31034;&#30456;&#37051;&#20004;&#34892;&#39030;&#37096;&#38388;&#30340;&#36317;&#31163;&#10;&#160;&#160;&#160;&#160;static const float fSqrt3_2 = 0.8660254f;&#10;&#160;&#160;&#160;&#160;//&#35745;&#31639;&#21487;&#20197;&#25490;&#19979;&#30340;&#24635;&#34892;&#25968;&#12290;&#38500;&#26368;&#24213;&#34892;&#39640;&#20026;1&#65292;&#20854;&#20313;&#34892;&#39640;&#20026;fSqrt3_2&#10;&#160;&#160;&#160;&#160;int nRows = (y &#62;= 1) + (int)((y - 1) / fSqrt3_2);&#10;&#160;&#160;&#160;&#160;//&#20808;&#35745;&#31639;&#20986;&#26368;&#24213;&#19968;&#34892;&#25490;&#28385;&#30340;&#21015;&#25968;&#65292;&#22914;&#26524;&#26368;&#24213;&#34892;&#21097;&#19979;&#30340;&#31354;&#38388;&#19981;&#36275;0.5&#10;&#160;&#160;&#160;&#160;//&#21017;&#35828;&#26126;&#22855;&#25968;&#34892;(&#24213;&#34892;&#20026;0)&#30340;&#21015;&#25968;&#27604;&#20598;&#25968;&#34892;&#23569;1&#20010;&#65292;&#35201;&#23545;&#22855;&#25968;&#34892;&#27599;&#34892;&#20943;1&#10;&#160;&#160;&#160;&#160;return (nRows * (int)x - (nRows / 2) * (x - (int)x &#60; 0.5f));&#10;&#125;&#10;//&#20027;&#20989;&#25968;&#10;int main(void) &#123;&#10;&#160;&#160;&#160;&#160;//&#24490;&#29615;&#35835;&#20837;&#24182;&#22788;&#29702;&#25152;&#26377;&#25968;&#25454;&#10;&#160;&#160;&#160;&#160;for (float x, y; cin &#62;&#62; x &#62;&#62; y; cout &#60;&#60; endl) &#123;&#10;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#32593;&#26684;&#26041;&#24335;&#25490;&#21015;&#65292;&#21363;&#20026;&#31616;&#21333;&#30340;&#34892;&#21015;&#21462;&#25972;&#12290;&#20132;&#38169;&#26041;&#24335;&#35201;&#35745;&#31639;&#20004;&#20010;&#26041;&#21521;&#10;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int nGrid = (int)x * (int)y, nSkew = max(Skew(x, y), Skew(y, x));&#10;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#36755;&#20986;&#26368;&#22823;&#30340;&#31649;&#23376;&#25968;&#21450;&#20854;&#25490;&#21015;&#26041;&#24335;&#10;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &#60;&#60; max(nGrid, nSkew) &#60;&#60; (nGrid &#62;= nSkew ? &#34; grid&#34; : &#34; skew&#34;);&#10;&#160;&#160;&#160;&#160;&#125;&#10;&#160;&#160;&#160;&#160;return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>上文参考：</p>
<ul>
<li><a href="http://www.cnblogs.com/devymex/archive/2010/08/15/1799966.html" target="_blank" rel="external">http://www.cnblogs.com/devymex/archive/2010/08/15/1799966.html</a> </li>
</ul>
<h2 id="B_poj1654">B poj1654</h2><p>题意：从直角坐标系的原点，移动n步，每一步，可以向八个方向移动（九宫格中间向周围的八个方向移动），最终会形成一个规范的多边形（可凸可凹），求多边形面积，<br>简单利用叉积求多边形面积即可（有向面积的利用），注意要用__int64</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#include &#60;iostream&#62;&#10;#include &#60;cstdio&#62;&#10;#include &#60;cstring&#62;&#10;using namespace std;&#10;&#10;int dir[10][2] = &#123;&#123;0, 0&#125;, &#123;-1, -1&#125;, &#123;0, -1&#125;, &#123;1, -1&#125;, &#123;-1, 0&#125;, &#123;0, 0&#125;, &#123;1, 0&#125;, &#123;-1, 1&#125;, &#123;0, 1&#125;, &#123;1, 1&#125;&#125;;&#10;char str[1000005];&#10;&#10;void func(char str[], int&#38; i, __int64&#38; x, __int64&#38; y) &#123;&#10;    while (str[i] != &#39;5&#39; &#38;&#38; str[i] == str[i-1]) &#123;&#10;        x += dir[str[i]-&#39;0&#39;][0];&#10;        y += dir[str[i]-&#39;0&#39;][1];&#10;        i++;&#10;    &#125;&#10;&#125;&#10;int main()&#10;&#123;&#10;    int n, i;&#10;&#10;    scanf (&#34;%d&#34;, &#38;n);&#10;    while (n--) &#123;&#10;       scanf (&#34;%s&#34;, str);&#10;       if (str[0] == &#39;5&#39;) &#123;&#10;          printf (&#34;0\n&#34;); continue;&#10;       &#125;&#10;       __int64 x1 = dir[str[0]-&#39;0&#39;][0], y1 = dir[str[0]-&#39;0&#39;][1], x2, y2;&#10;       __int64 area = 0;&#10;       i = 1;&#10;       func(str, i, x1, y1);&#10;       for (; str[i] != &#39;5&#39;;) &#123;&#10;           x2 = x1 + dir[str[i]-&#39;0&#39;][0];&#10;           y2 = y1 + dir[str[i]-&#39;0&#39;][1];&#10;           i++;&#10;           func(str, i, x2, y2);&#10;           area += x1 * y2 - x2 * y1;&#10;           x1 = x2;&#10;           y1 = y2;&#10;       &#125;&#10;       if (area &#60; 0) area = -area;&#10;       printf (&#34;%I64d&#34;, area/2);&#10;       if (area % 2) printf (&#34;.5&#34;);&#10;       printf (&#34;\n&#34;);&#10;    &#125;&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li><a href="http://blog.csdn.net/non_cease/article/details/7795485" target="_blank" rel="external">http://blog.csdn.net/non_cease/article/details/7795485</a></li>
</ul>
<h2 id="C_hrbust_1304">C hrbust 1304</h2><p>简单的叉积应用，上课提到过。代码很简单就不贴了。</p>
<h2 id="D_hrbust_1305">D hrbust 1305</h2><p>这题考察利用叉积对点排序，也是凸包的基础。简单得按照叉积排序就OK了<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">#include&#60;stdio.h&#62;&#10;#include&#60;math.h&#62;&#10;#include&#60;string.h&#62;&#10;#include&#60;algorithm&#62;&#10;using namespace std;&#10;struct point&#10;&#123;&#10;    double x,y;&#10;&#125;p[100];&#10;bool cmp(point a,point b)&#10;&#123;&#10;    double X=atan2(a.y,a.x);&#10;    double Y=atan2(b.y,b.x);&#10;    return X&#60;Y;&#10;&#125;&#10;int main()&#10;&#123;&#10;    int n,i;&#10;    while(~scanf(&#34;%d&#34;,&#38;n))&#10;    &#123;&#10;        if(n==0)break;&#10;        for(i=0;i&#60;n;i++)&#10;        &#123;&#10;            scanf(&#34;%lf %lf&#34;,&#38;p[i].x,&#38;p[i].y);&#10;        &#125;&#10;        sort(p+1,p+n,cmp);&#10;        printf(&#34;(0,0)\n&#34;);&#10;        for(i=1;i&#60;n;i++)&#10;        &#123;&#10;            printf(&#34;(%d,%d)\n&#34;,(int)p[i].x,(int)p[i].y);&#10;        &#125;&#10;    &#125;&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="E_hrbust_1306">E hrbust 1306</h2><p>也是上课讲的例题，无需再多加解释了，代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#by freecode@hrbust &#10;#include &#60;stdio.h&#62;&#10;struct Point&#123;&#10;    double x,y;&#10;&#125;;&#10;struct Line&#123;&#10;    Point p1,p2;&#10;&#125;;&#10;double xmulti(Point p1,Point p2,Point p0)    //&#27714;p1p0&#21644;p2p0&#30340;&#21449;&#31215;,&#22914;&#26524;&#22823;&#20110;0,&#21017;p1&#22312;p2&#30340;&#39034;&#26102;&#38024;&#26041;&#21521;&#10;&#123;&#10;    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#10;&#125;&#10;double Max(double a,double b)&#10;&#123;&#10;    return a&#62;b?a:b;&#10;&#125;&#10;double Min(double a,double b)&#10;&#123;&#10;    return a&#60;b?a:b;&#10;&#125;&#10;bool ponls(Point q,Line l)    //&#21028;&#26029;&#28857;q&#26159;&#21542;&#22312;&#32447;&#27573;l&#19978;&#10;&#123;&#10;    if(q.x &#62; Max(l.p1.x,l.p2.x) || q.x &#60; Min(l.p1.x,l.p2.x)&#10;        || q.y &#62; Max(l.p1.y,l.p2.y) || q.y &#60; Min(l.p1.y,l.p2.y) )&#10;        return false;&#10;    if(xmulti(l.p1,l.p2,q)==0)    //&#28857;q&#19981;&#22312;l&#30340;&#24310;&#38271;&#32447;&#25110;&#32773;&#21453;&#21521;&#24310;&#38271;&#32447;&#19978;&#65292;&#22914;&#26524;&#21449;&#31215;&#20877;&#20026;0&#65292;&#21017;&#30830;&#23450;&#28857;q&#22312;&#32447;&#27573;l&#19978;&#10;        return true;&#10;    else&#10;        return false;&#10;&#125;&#10;bool pinplg(int pointnum,Point p[],Point q)&#10;&#123;&#10;    Line s;&#10;    int c = 0;&#10;    for(int i=1;i&#60;=pointnum;i++)&#123;    //&#22810;&#36793;&#24418;&#30340;&#27599;&#26465;&#36793;s&#10;        if(i==pointnum)&#10;            s.p1 = p[pointnum],s.p2 = p[1];&#10;        else&#10;            s.p1 = p[i],s.p2 = p[i+1];&#10;        if(ponls(q,s))    //&#28857;q&#22312;&#36793;s&#19978;&#10;            return true;&#10;        if(s.p1.y != s.p2.y)&#123;    //s&#19981;&#26159;&#27700;&#24179;&#30340;&#10;            Point t;&#10;            t.x = q.x - 1,t.y = q.y;&#10;            if( (s.p1.y == q.y &#38;&#38; s.p1.x &#60;=q.x) || (s.p2.y == q.y &#38;&#38; s.p2.x &#60;= q.x) )&#123;    //s&#30340;&#19968;&#20010;&#31471;&#28857;&#22312;L&#19978;&#10;                int tt;&#10;                if(s.p1.y == q.y)&#10;                    tt = 1;&#10;                else if(s.p2.y == q.y)&#10;                    tt = 2;&#10;                int maxx;&#10;                if(s.p1.y &#62; s.p2.y)&#10;                    maxx = 1;&#10;                else&#10;                    maxx = 2;&#10;                if(tt == maxx) //&#22914;&#26524;&#36825;&#20010;&#31471;&#28857;&#30340;&#32437;&#22352;&#26631;&#36739;&#22823;&#30340;&#37027;&#20010;&#31471;&#28857;&#10;                    c++;&#10;            &#125;&#10;            else if(xmulti(s.p1,t,q)*xmulti(s.p2,t,q) &#60;= 0)&#123;    //L&#21644;&#36793;s&#30456;&#20132;&#10;                Point lowp,higp;&#10;                if(s.p1.y &#62; s.p2.y)&#10;                    lowp.x = s.p2.x,lowp.y = s.p2.y,higp.x = s.p1.x,higp.y = s.p1.y;&#10;                else&#10;                    lowp.x = s.p1.x,lowp.y = s.p1.y,higp.x = s.p2.x,higp.y = s.p2.y;&#10;                if(xmulti(q,higp,lowp)&#62;=0)&#10;                    c++;&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;    if(c%2==0)&#10;        return false;&#10;    else&#10;        return true;&#10;&#125;&#10;int main()&#10;&#123;&#10;&#9;int i,n;&#10;&#9;while(scanf(&#34;%d&#34;,&#38;n)!=EOF)&#123;&#10;&#9;&#9;if(n==0) break;&#10;&#9;&#9;Point t;&#10;&#9;&#9;scanf(&#34;%lf%lf&#34;,&#38;t.x,&#38;t.y);&#10;&#9;&#9;Point p[101];&#10;&#9;&#9;for(i=1;i&#60;=n;i++)&#9;//&#36755;&#20837;&#22810;&#36793;&#24418;&#30340;&#39030;&#28857;&#10;&#9;&#9;scanf(&#34;%lf%lf&#34;,&#38;p[i].x,&#38;p[i].y);&#10;&#9;&#9;if(pinplg(n,p,t))&#10;&#9;&#9;&#9;printf(&#34;Yes\n&#34;);&#10;&#9;&#9;else&#10;&#9;&#9;&#9;printf(&#34;No\n&#34;);&#10;&#9;&#125;&#10;&#9;return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F_poj1113">F poj1113</h2><p>上课的例题，直接看如何实现的吧：(如果不懂，请转：<a href="http://blog.csdn.net/lyy289065406/article/details/6648622" target="_blank" rel="external">http://blog.csdn.net/lyy289065406/article/details/6648622</a>)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//Memory Time &#10;//244K   63MS &#10;&#10;#include&#60;iostream&#62;&#10;#include&#60;cmath&#62;&#10;#include&#60;iomanip&#62;&#10;using namespace std;&#10;&#10;const int inf=10001;&#10;const double pi=3.141592654;&#10;&#10;typedef class&#10;&#123;&#10;&#9;public:&#10;&#9;&#9;int x,y;&#10;&#125;point;&#10;&#10;/*AB&#36317;&#31163;&#24179;&#26041;*/&#10;&#10;int distsquare(point A,point B)&#10;&#123;&#10;&#9;return (B.x-A.x)*(B.x-A.x)+(B.y-A.y)*(B.y-A.y);&#10;&#125;&#10;&#10;/*AB&#36317;&#31163;*/&#10;&#10;double distant(point A,point B)&#10;&#123;&#10;&#9;return sqrt((double)((B.x-A.x)*(B.x-A.x)+(B.y-A.y)*(B.y-A.y)));&#10;&#125;&#10;&#10;/*&#21449;&#31215;&#35745;&#31639;*/&#10;&#10;int det(int x1,int y1,int x2,int y2)&#10;&#123;&#10;&#9;return x1*y2-x2*y1;&#10;&#125;&#10;&#10;int cross(point A,point B,point C,point D)&#10;&#123;&#10;&#9;return det(B.x-A.x,B.y-A.y,D.x-C.x,D.y-C.y);&#10;&#125;&#10;&#10;/*&#24555;&#25490;&#21028;&#26029;&#35268;&#21017;*/&#10;&#10;point* s;&#10;int cmp(const void* pa,const void* pb)&#10;&#123;&#10;&#9;point* a=(point*)pa;&#10;&#9;point* b=(point*)pb;&#10;&#10;&#9;int temp=cross(*s,*a,*s,*b);&#10;&#9;if(temp&#62;0)&#10;&#9;&#9;return -1;&#10;&#9;else if(temp==0)&#10;&#9;&#9;return distsquare(*s,*b)-distsquare(*s,*a);&#10;&#9;else&#10;&#9;&#9;return 1;&#10;&#125;&#10;&#10;int main(int i,int j)&#10;&#123;&#10;&#9;int N,L;&#10;&#9;while(cin&#62;&#62;N&#62;&#62;L)&#10;&#9;&#123;&#10;&#9;&#9;/*Input*/&#10;&#10;&#9;&#9;point* node=new point[N+1];&#10;&#10;&#9;&#9;int min_x=inf;&#10;&#9;&#9;int fi;&#10;&#9;&#9;for(i=1;i&#60;=N;i++)&#10;&#9;&#9;&#123;&#10;&#9;&#9;&#9;cin&#62;&#62;node[i].x&#62;&#62;node[i].y;&#10;&#10;&#9;&#9;&#9;if(min_x &#62; node[i].x)&#10;&#9;&#9;&#9;&#123;&#10;&#9;&#9;&#9;&#9;min_x = node[i].x;&#10;&#9;&#9;&#9;&#9;fi=i;&#10;&#9;&#9;&#9;&#125;&#10;&#9;&#9;&#9;else if(min_x == node[i].x)&#10;&#9;&#9;&#9;&#9;if(node[fi].y &#62; node[i].y)&#10;&#9;&#9;&#9;&#9;&#9;fi=i;&#10;&#9;&#9;&#125;&#10;&#10;&#9;&#9;/*Quicksort the Vertex*/&#10;&#10;&#9;&#9;node[0]=node[N];&#10;&#9;&#9;node[N]=node[fi];&#10;&#9;&#9;node[fi]=node[0];&#10;&#10;&#9;&#9;s=&#38;node[N];&#10;&#9;&#9;qsort(node+1,N,sizeof(point),cmp);&#10;&#10;&#9;&#9;/*Structure Con-bag*/&#10;&#10;&#9;&#9;int* bag=new int[N+2];&#10;&#9;&#9;bag[1]=N;&#10;&#9;&#9;bag[2]=1;&#10;&#9;&#9;int pb=2;&#10;&#9;&#9;for(i=2;i&#60;=N;)&#10;&#9;&#9;&#9;if(cross(node[ bag[pb-1] ],node[ bag[pb] ],node[ bag[pb] ],node[i]) &#62;= 0)&#10;&#9;&#9;&#9;&#9;bag[++pb]=i++;&#10;&#9;&#9;&#9;else&#10;&#9;&#9;&#9;&#9;pb--;&#10;&#10;&#9;&#9;/*Compute Min-length*/&#10;&#10;&#9;&#9;double minlen=0;&#10;&#9;&#9;for(i=1;i&#60;pb;i++)&#10;&#9;&#9;&#9;minlen+=distant(node[ bag[i] ],node[ bag[i+1] ]);&#10;&#10;&#9;&#9;minlen+=2*pi*L;&#10;&#10;&#9;&#9;cout&#60;&#60;fixed&#60;&#60;setprecision(0)&#60;&#60;minlen&#60;&#60;endl;&#10;&#10;&#9;&#9;delete node;&#10;&#9;&#9;delete bag;&#10;&#9;&#125;&#10;&#9;return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="G_poj2187">G poj2187</h2><p>求最远点对，暴力凸包上的点就可以过。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//Memory Time &#10;//812K   469MS &#10;&#10;#include&#60;iostream&#62;&#10;using namespace std;&#10;&#10;const int inf=10001;&#10;&#10;typedef class location&#10;&#123;&#10;&#9;public:&#10;&#9;&#9;int x,y;&#10;&#125;node;&#10;&#10;/*&#28857;A&#21040;&#28857;B&#30340;&#36317;&#31163;&#30340;&#24179;&#26041;*/&#10;&#10;int distsquare(node A,node B)&#10;&#123;&#10;&#9;return (B.x-A.x)*(B.x-A.x)+(B.y-A.y)*(B.y-A.y);&#10;&#125;&#10;&#10;/*&#35745;&#31639;&#21449;&#31215;*/&#10;&#10;int det(int x1,int y1,int x2,int y2)&#10;&#123;&#10;&#9;return x1*y2-x2*y1;&#10;&#125;&#10;&#10;int cross(node A,node B,node C,node D)&#10;&#123;&#10;&#9;return det(B.x-A.x , B.y-A.y , D.x-C.x , D.y-C.y);&#10;&#125;&#10;&#10;/*qsort&#27604;&#36739;&#35268;&#21017;*/&#10;&#10;node* p;  //&#26497;&#22352;&#26631;&#21407;&#28857;&#10;int cmp(const void* a,const void* b)&#10;&#123;&#10;&#9;node* s=(node*)a;&#10;&#9;node* t=(node*)b;&#10;&#10;&#9;int temp=cross(*p,*s,*p,*t);  //&#21449;&#20056;ps X pt &#10;&#9;if(temp&#62;0)    //&#35828;&#26126;pt&#21521;&#37327;&#30340;&#26497;&#35282; &#23567;&#20110; ps&#21521;&#37327;&#30340;&#26497;&#35282;&#10;&#9;&#9;return -1;  //&#20174;&#36870;&#26102;&#38024;&#25490;&#24207;&#35282;&#24230;&#65292;t&#28857;&#20301;&#32622;&#22312;s&#28857;&#21069;&#38754;&#65292;&#21363;t&#60;s &#65292;&#26681;&#25454;qsort&#35268;&#21017;&#36820;&#22238;-1&#10;&#10;&#9;else if(temp==0) //&#35828;&#26126;pt&#21521;&#37327;&#30340;&#26497;&#35282; &#31561;&#20110; ps&#21521;&#37327;&#30340;&#26497;&#35282;&#10;&#9;&#9;return distsquare(*p,*t)-distsquare(*p,*s);  //&#36317;&#31163;&#21407;&#28857;&#36817;&#30340;&#28857;&#20248;&#20808;&#25490;&#24207;&#65292;&#29992;&#20943;&#27861;&#33021;&#22815;&#23454;&#29616;3&#20986;&#21475;&#65306;- 0 +&#10;&#9;                    //&#27880;&#24847;&#65292;&#32593;&#19978;&#26377;&#20123;&#31243;&#24207;&#22312;&#36825;&#37324;&#19981;&#26159;&#27604;&#36739; &#36317;&#31163;&#20043;&#24046;&#65292;&#32780;&#26159;&#27604;&#36739; &#27178;&#22352;&#26631;&#32477;&#23545;&#20540; &#20043;&#24046;&#10;&#9;                    //&#36825;&#26159;&#27424;&#32570;&#32771;&#34385;  &#22810;&#28857;&#19982;&#21407;&#28857;&#36830;&#32447; &#22402;&#30452;&#20110;x&#36724;&#65292;&#19981;&#23436;&#21892;&#65292;&#20043;&#25152;&#20197;&#33021;AC&#26159;&#22240;&#20026;POJ&#30340;&#25968;&#25454;&#24211;&#19981;&#36275;&#22815;&#22823;&#32780;&#24050;&#10;&#9;else&#10;&#9;&#9;return 1; //pt&#21521;&#37327;&#30340;&#26497;&#35282; &#22823;&#20110; ps&#21521;&#37327;&#30340;&#26497;&#35282;&#10;&#125;&#10;&#10;int main(int i,int j)&#10;&#123;&#10;&#9;int n;&#10;&#9;while(cin&#62;&#62;n)&#10;&#9;&#123;&#10;&#9;&#9;node* farm=new node[n+1];&#10;&#9;&#9;int* conbag=new int[n+2];  //conbag[]&#39034;&#24207;&#35760;&#24405;&#36755;&#20837;&#30340;&#28857;&#20013;&#26500;&#36896;&#25104;&#20984;&#21253;&#30340;&#39030;&#28857;&#38598;&#30340;&#21508;&#28857;&#22312;farm[]&#20013;&#30340;&#19979;&#26631;&#10;&#10;&#9;&#9;/*Input &#38; search the first vertex*/&#10;&#10;&#9;&#9;int min_x=inf;&#10;&#9;&#9;int fi=0;&#10;&#9;&#9;for(i=1;i&#60;=n;i++)&#10;&#9;&#9;&#123;&#10;&#9;&#9;&#9;cin&#62;&#62;farm[i].x&#62;&#62;farm[i].y;&#10;&#10;&#9;&#9;&#9;if(min_x &#62; farm[i].x)&#10;&#9;&#9;&#9;&#123;&#10;&#9;&#9;&#9;&#9;min_x = farm[i].x;   //&#20808;&#20197;&#27178;&#22352;&#26631;&#20026;&#31532;&#19968;&#20851;&#38190;&#23383;&#25628;&#32034;&#26368;&#24038;&#19979;&#35282;&#30340;&#28857;&#10;&#9;&#9;&#9;&#9;fi=i;&#10;&#9;&#9;&#9;&#125;&#10;&#9;&#9;&#9;else if(min_x == farm[i].x)&#10;&#9;&#9;&#9;&#123;&#10;&#9;&#9;&#9;&#9;if(farm[fi].y &#62; farm[i].y)   //&#33509;&#31532;&#19968;&#20851;&#38190;&#23383;&#30456;&#21516;&#65292;&#21017;&#20197;&#32437;&#22352;&#26631;&#20316;&#20026;&#31532;&#20108;&#20851;&#38190;&#25628;&#32034;&#10;&#9;&#9;&#9;&#9;&#9;fi=i;&#10;&#9;&#9;&#9;&#125;&#10;&#9;&#9;&#125;&#10;&#10;&#9;&#9;/*Quicksort Point Sets*/&#10;&#10;&#9;&#9;farm[0]=farm[n];   //&#36825;&#19977;&#27493;&#38750;&#24120;&#20851;&#38190;&#65292;&#26159;&#20351;&#29992;qsort&#21069;&#30340;&#20934;&#22791;&#24037;&#20316;&#10;&#9;&#9;farm[n]=farm[fi];  //&#30446;&#30340;&#26159;&#25226;&#21069;&#38754;&#25214;&#21040;&#30340;&#26368;&#24038;&#19979;&#35282;&#30340;&#28857;&#20316;&#20026; &#26497;&#22352;&#26631;&#21407;&#28857;&#10;&#9;&#9;farm[fi]=farm[0];  //&#21363;&#25226;&#31532;fi&#20010;&#28857;&#31227;&#21040;farm[]&#26368;&#21518;&#30340;&#20301;&#32622;,qsort&#21017;&#20250;&#25226;&#23427;&#20316;&#20026;&#25490;&#24207;&#30340;&#21442;&#32771;&#28857;&#10;&#10;&#9;&#9;p=&#38;farm[n]; //&#26497;&#22352;&#26631;&#21407;&#28857;&#20256;&#21442;&#10;&#10;&#9;&#9;qsort(farm+1,n,sizeof(node),cmp);  //farm[]&#25955;&#28857;&#38598;&#25490;&#24207;&#10;&#10;&#9;&#9;/*Graham Scan Algorithm*/&#10;&#10;&#9;&#9;int pc=1;  //conbag[]&#25351;&#38024;&#10;&#9;&#9;conbag[1]=n;  //(&#32422;&#23450;)&#26497;&#22352;&#26631;&#21407;&#28857; &#20026;&#20984;&#21253;&#31532;1&#20010;&#39030;&#28857;&#10;&#9;&#9;conbag[++pc]=1; //(&#22312;&#21069;&#38754;&#22522;&#30784;&#19978;,)&#26377;&#24207;&#28857;&#38598;farm[]&#30340;&#31532;&#19968;&#20010;&#28857; (&#24517;)&#20026;&#20984;&#21253;&#31532;2&#20010;&#39030;&#28857;&#10;&#9;&#9;conbag[0]=2;   //&#20984;&#21253;&#39030;&#28857;&#35745;&#25968;&#22120;&#10;&#10;&#9;&#9;for(i=2;i&#60;=n;)&#10;&#9;&#9;&#9;if(cross(farm[ conbag[pc-1] ],farm[ conbag[pc] ],farm[ conbag[pc] ],farm[i]) &#62;= 0)&#10;&#9;&#9;&#9;&#123;   //&#26816;&#26597;&#21521;&#37327;(&#21069;&#19968;&#28857;pc-1,&#24403;&#21069;&#28857;pc) &#19982; &#21521;&#37327;(&#24403;&#21069;&#28857;pc,&#24453;&#20837;&#26632;&#28857;i) &#30340;&#26059;&#36716;&#20851;&#31995;&#10;&#9;&#9;&#9;&#9;conbag[++pc]=i++;  //&#20837;&#26632;&#10;&#9;&#9;&#9;&#9;conbag[0]++;&#10;&#9;&#9;&#9;&#125;&#10;&#9;&#9;&#9;else&#10;&#9;&#9;&#9;&#123;&#10;&#9;&#9;&#9;&#9;pc--;         //&#24403;&#21069;&#28857;pc&#20986;&#26632;&#10;&#9;&#9;&#9;&#9;conbag[0]--;&#10;&#9;&#9;&#9;&#125;&#10;&#10;&#9;&#9;/*Search The Max distant*/&#10;&#10;&#9;&#9;int maxdist=0;&#10;&#9;&#9;for(i=1;i&#60;=conbag[0]-2;i++)          //&#25955;&#28857;&#38598;&#30340;&#20004;&#28857;&#26368;&#22823;&#36317;&#31163;&#24517;&#23450;&#20986;&#29616;&#22312;&#35813;&#25955;&#28857;&#38598;&#30340;&#20984;&#21253;&#30340;&#26576;&#20004;&#20010;&#39030;&#28857;&#20043;&#38388;&#10;&#9;&#9;&#9;for(j=i+1;j&#60;=conbag[0]-1;j++)&#10;&#9;&#9;&#9;&#123;&#10;&#9;&#9;&#9;&#9;int temp=distsquare(farm[ conbag[i] ],farm[ conbag[j] ]);&#10;&#9;&#9;&#9;&#9;if(maxdist &#60; temp)&#10;&#9;&#9;&#9;&#9;&#9;maxdist = temp;&#10;&#9;&#9;&#9;&#125;&#10;&#10;&#9;&#9;/*Output*/&#10;&#10;&#9;&#9;cout&#60;&#60;maxdist&#60;&#60;endl;&#10;&#10;&#10;&#9;&#9;delete farm;&#10;&#9;&#9;delete conbag;&#10;&#9;&#125;&#10;&#9;return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="I_POJ1873">I POJ1873</h2><p>题意：平面上有n棵树，现在要砍掉其中的一部分来做成篱笆将剩下的树包围起来，现在给出每棵树的坐标、价值和可以制造篱笆的长度，<br>          求砍掉最少价值的树，将剩下的树包围起来，当两种方式的价值相同时，取砍掉树更少的方式。<br>由于树棵树不大于15，可以二进制枚举情况，求出其它树构成的凸包的周长即可</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#include &#60;iostream&#62;&#10;#include &#60;cstdio&#62;&#10;#include &#60;cmath&#62;&#10;#include &#60;algorithm&#62;&#10;using namespace std;&#10;&#10;const double eps = 1e-8;&#10;const double inf = 999999999;&#10;&#10;int stk[20], top, tc[20], cuted[20], num;&#10;&#10;struct Point &#123;&#10;    double x, y, v, l;&#10;    Point&#38; operator=(Point a) &#123;&#10;         x = a.x; y = a.y;&#10;         v = a.v; l = a.l;&#10;         return *this;&#10;    &#125;&#10;&#125; pnt[20], p[20];&#10;&#10;int dblcmp(double k) &#123;&#10;    if (fabs(k) &#60; eps) return 0;&#10;    return k &#62; 0 ? 1 : -1;&#10;&#125;&#10;&#10;double multi(Point p0, Point p1, Point p2) &#123;&#10;    return (p1.x-p0.x)*(p2.y-p0.y)-(p1.y-p0.y)*(p2.x-p0.x);&#10;&#125;&#10;&#10;double getDis(Point a, Point b) &#123;&#10;    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#10;&#125;&#10;&#10;bool cmp(const Point&#38; a, const Point&#38; b) &#123;&#10;    int d = dblcmp(multi(p[0], a, b));&#10;    if (!d) return getDis(p[0], a) &#60; getDis(p[0], b);&#10;    return d &#62; 0;&#10;&#125;&#10;&#10;double solve(Point p[], int sz) &#123;&#10;    if (sz &#60;= 1) return 0;&#10;&#10;    int i, k = 0;&#10;    Point tp = p[0];&#10;    for (i = 1; i &#60; sz; i++) &#123;&#10;        int d = dblcmp(tp.y-p[i].y);&#10;        if ((!d &#38;&#38; dblcmp(tp.x-p[i].x) &#62; 0) || d &#62; 0) &#123;&#10;            k = i;&#10;            tp = p[i];&#10;        &#125;&#10;    &#125;&#10;    p[k] = p[0];&#10;    p[0] = tp;&#10;&#10;    sort(p+1, p+sz, cmp);&#10;    stk[0] = 0; stk[1] = 1;&#10;    top = 1;&#10;    for (i = 2; i &#60; sz; i++) &#123;&#10;        while (top &#62;= 1 &#38;&#38; dblcmp(multi(p[stk[top-1]], p[i], p[stk[top]])) &#62;= 0) top--;&#10;        stk[++top] = i;&#10;    &#125;&#10;    double len = 0;&#10;    for (i = 0; i &#60; top; i++)&#10;        len += getDis(p[stk[i]], p[stk[i+1]]);&#10;    return len+getDis(p[stk[top]], p[0]);&#10;&#125;&#10;&#10;int main()&#10;&#123;&#10;    int n, i, j, cas = 0;&#10;&#10;    while (scanf (&#34;%d&#34;, &#38;n) &#38;&#38; n) &#123;&#10;        cas++;&#10;        for (i = 0; i &#60; n; i++)&#10;            scanf (&#34;%lf%lf%lf%lf&#34;, &#38;pnt[i].x, &#38;pnt[i].y, &#38;pnt[i].v, &#38;pnt[i].l);&#10;        int n0, n1, N = 1 &#60;&#60; n;&#10;        double val, len, minVal = inf, extra;&#10;        num = n;&#10;        for (i = 1; i &#60; N-1; i++) &#123;&#10;             len = val = 0;&#10;             n0 = n1 = 0;&#10;             for (j = 0; j &#60; n; j++)&#10;                if ((i&#62;&#62;j)&#38;1) &#123;&#10;                    tc[n0++] = j;&#10;                    val += pnt[j].v;&#10;                    len += pnt[j].l;&#10;                &#125; else p[n1++] = pnt[j];&#10;             double tl = solve(p, n1);&#10;             if (dblcmp(len-tl) &#62;= 0) &#123;&#10;                int d = dblcmp(minVal-val);&#10;                if (d &#62; 0 || (!d &#38;&#38; n0 &#60; num)) &#123;&#10;                    minVal = val;&#10;                    for (j = 0; j &#60; n0; j++) cuted[j] = tc[j];&#10;                    num = n0;&#10;                    extra = len-tl;&#10;                &#125;&#10;             &#125;&#10;        &#125;&#10;        printf (&#34;Forest %d\nCut these trees:&#34;, cas);&#10;        for (i = 0; i &#60; num; i++)&#10;            printf (&#34; %d&#34;, cuted[i]+1);&#10;        printf(&#34;\nExtra wood: %.2lf\n\n&#34;, extra);&#10;    &#125;&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://moonsn.com/2015/04/24/ACM0424/" data-id="ci8vhd01q000088wehjyufrwx" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2015/04/07/something-with-cplusplus/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">something with cplusplus</div>
    </a>
  
</nav>

  
</article>


</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 moonsn<br>
      Proudly published with <a target="_blank" href="http://hexo.io">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    

<script src="http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js"></script>
<script src="http://cdn.staticfile.org/scrollReveal.js/0.1.2/scrollReveal.min.js"></script>

  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script>
  window.scrollReveal = new scrollReveal();
</script>

<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>
