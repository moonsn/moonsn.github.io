<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>moonsn&#39;s profile</title>
    <link>http://moonsn.com/</link>
    <description>Recent content on moonsn&#39;s profile</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Wed, 21 Oct 2015 19:54:25 +0800</lastBuildDate>
    <atom:link href="http://moonsn.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Hugo生成静态文件</title>
      <link>http://moonsn.com/post/deploymenthugo/</link>
      <pubDate>Wed, 21 Oct 2015 19:54:25 +0800</pubDate>
      
      <guid>http://moonsn.com/post/deploymenthugo/</guid>
      <description>&lt;pre&gt;&lt;code&gt;$ sudo hugo server --watch --baseUrl=http://yoursite.org/ --appendPort=false
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang中的方法与接口</title>
      <link>http://moonsn.com/post/golang_3/</link>
      <pubDate>Wed, 21 Oct 2015 19:46:01 +0800</pubDate>
      
      <guid>http://moonsn.com/post/golang_3/</guid>
      <description>

&lt;h3 id=&#34;方法:1fe650016e84e1375349ba764bbab8d3&#34;&gt;方法&lt;/h3&gt;

&lt;p&gt;Go虽然没有类，但是可以在struct上定义方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math&amp;quot;
)

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func (v *Vertex) Show(what string) {
	fmt.Println(&amp;quot;show &amp;quot;, what)
}

func main() {
	v := &amp;amp;Vertex{3, 4}
	fmt.Println(v.Abs())
	v.Show(&amp;quot;me&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实，只要在你的包里声明的任何类型都可以定义方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math&amp;quot;
)

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f &amp;lt; 0 {
		return float64(-f)
	}
	return float64(f)
}

func main() {
	f := MyFloat(-math.Sqrt2)
	fmt.Println(f.Abs())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常方法是绑在指针上，这样避免了在传参的时候复制，也便于方法直接修改指针所指向的值。&lt;/p&gt;

&lt;h3 id=&#34;接口:1fe650016e84e1375349ba764bbab8d3&#34;&gt;接口&lt;/h3&gt;

&lt;p&gt;接口类型是一个包含&lt;code&gt;一组方法定义&lt;/code&gt;的集合。也就是接口里定义了一组方法。&lt;/p&gt;

&lt;p&gt;只要一个类型实现了这个接口了的方法，就能赋给这个接口类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math&amp;quot;
)

type Abser interface {
	Abs() float64
}

func main() {
	var a Abser
	f := MyFloat(-math.Sqrt2)
	v := Vertex{3, 4}

	a = f  // a MyFloat 实现了 Abser
	a = &amp;amp;v // a *Vertex 实现了 Abser

	// 下面一行，v 是一个 Vertex（而不是 *Vertex）
	// 所以没有实现 Abser。
	a = v

	fmt.Println(a.Abs())
}

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f &amp;lt; 0 {
		return float64(-f)
	}
	return float64(f)
}

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;exercise-stringer-go:1fe650016e84e1375349ba764bbab8d3&#34;&gt;exercise-stringer.go&lt;/h3&gt;

&lt;p&gt;这是对&lt;code&gt;fmt&lt;/code&gt;包里的&lt;code&gt;Stringer&lt;/code&gt;接口的使用，实现了他里面定义的&lt;code&gt;String() string&lt;/code&gt;方法.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Stringer&lt;/code&gt;是一个用&lt;code&gt;string&lt;/code&gt;描述自己的接口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type IPAddr [4]byte

// TODO: Add a &amp;quot;String() string&amp;quot; method to IPAddr.
func (x IPAddr) String() string {
	return fmt.Sprintf(&amp;quot;%d.%d.%d.%d&amp;quot;, x[0],x[1],x[2],x[3]);
}

func main() {
	addrs := map[string]IPAddr{
		&amp;quot;loopback&amp;quot;:  {127, 0, 0, 1},
		&amp;quot;googleDNS&amp;quot;: {8, 8, 8, 8},
	}
	for n, a := range addrs {
		fmt.Printf(&amp;quot;%v: %v\n&amp;quot;, n, a)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;error:1fe650016e84e1375349ba764bbab8d3&#34;&gt;Error&lt;/h3&gt;

&lt;p&gt;与fmt.Stringer类似，error类型是一个内建接口.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type error interface {
	Error() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常函数会返回一个 error 值，调用的它的代码应当判断这个错误是否等于 nil， 来进行错误处理。&lt;/p&gt;

&lt;p&gt;i, err := strconv.Atoi(&amp;ldquo;42&amp;rdquo;)
if err != nil {
    fmt.Printf(&amp;ldquo;couldn&amp;rsquo;t convert number: %v\n&amp;rdquo;, err)
}
fmt.Println(&amp;ldquo;Converted integer:&amp;ldquo;, i)
error 为 nil 时表示成功；非 nil 的 error 表示错误。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;exercise-errors.go&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type ErrNegativeSqrt float64

func (e ErrNegativeSqrt) Error() string {
	return fmt.Sprintf(&amp;quot;cannot Sqrt negative number: %v&amp;quot;, float64(e))
}

func Sqrt(x float64) (float64, error) {
	if x &amp;lt; 0 {
		return 0, ErrNegativeSqrt(x)
	}
	z := x
	for i := 0; i &amp;lt; 10; i++ {
		z = z - (z * z - x)/(2*z)
	}
	return z, nil
}



func main() {
	fmt.Println(Sqrt(2))
	fmt.Println(Sqrt(-2))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;exercise-rot-reader-go:1fe650016e84e1375349ba764bbab8d3&#34;&gt;exercise-rot-reader.go&lt;/h3&gt;

&lt;p&gt;这个开始没有读入到&lt;code&gt;io.Reader&lt;/code&gt;&amp;hellip;坑了半天&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;io&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strings&amp;quot;
)

type rot13Reader struct {
	r io.Reader
}

func (rot *rot13Reader) Read(bytes []byte) (int, error) {
	n, err := rot.r.Read(bytes)
	s := &amp;quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzNOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm&amp;quot;
	for index := range bytes {
		if !((bytes[index] &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; bytes[index] &amp;lt;=&#39;z&#39;) || (bytes[index] &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; bytes[index] &amp;lt;=&#39;Z&#39;)){
			continue
		}
		pos := strings.IndexByte(s, bytes[index])
		bytes[index] = s[pos + 26*2]
	}
	return n, err
}

func main() {
	s := strings.NewReader(&amp;quot;Lbh penpxrq gur pbqr!&amp;quot;)
	r := rot13Reader{s}
	io.Copy(os.Stdout, &amp;amp;r)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;web-servers:1fe650016e84e1375349ba764bbab8d3&#34;&gt;web servers&lt;/h3&gt;

&lt;p&gt;http包为任何实现了&lt;code&gt;http.Handler&lt;/code&gt;接口的值提供服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package http

type Handler interface {
    ServeHTTP(w ResponseWriter, r *Request)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;官网的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
)

type Hello struct{}

func (h Hello) ServeHTTP(
	w http.ResponseWriter,
	r *http.Request) {
	fmt.Fprint(w, &amp;quot;Hello!&amp;quot;)
}

func main() {
	var h Hello
	err := http.ListenAndServe(&amp;quot;localhost:4000&amp;quot;, h)
	if err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;exercise-http-handlers-go:1fe650016e84e1375349ba764bbab8d3&#34;&gt;exercise-http-handlers.go&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
		&amp;quot;fmt&amp;quot;
		&amp;quot;log&amp;quot;
		&amp;quot;net/http&amp;quot;
	   )

type String string

type Struct struct {
	Greeting	string
		Punct		string
		Who			string
}

func (str String) ServeHTTP(
		w http.ResponseWriter,
		r *http.Request) {
	fmt.Fprint(w, str)
}

func (stu *Struct) ServeHTTP(
		w http.ResponseWriter,
		r *http.Request) {
	fmt.Fprint(w,fmt.Sprintln(stu.Greeting, stu.Punct, stu.Who))
}

func main() {
	// your http.Handle calls here
	http.Handle(&amp;quot;/string&amp;quot;, String(&amp;quot;I&#39;m a frayed knot.&amp;quot;))
	http.Handle(&amp;quot;/struct&amp;quot;, &amp;amp;Struct{&amp;quot;Hello&amp;quot;, &amp;quot;:&amp;quot;, &amp;quot;Gophers!&amp;quot;})
	log.Fatal(http.ListenAndServe(&amp;quot;localhost:4000&amp;quot;, nil))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;excercise-images-go:1fe650016e84e1375349ba764bbab8d3&#34;&gt;excercise-images.go&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;golang.org/x/tour/pic&amp;quot;
import &amp;quot;image&amp;quot;
import &amp;quot;image/color&amp;quot;

type Image struct{
	w, h int
	colr uint8
}

func (IMG Image) ColorModel() color.Model {
	return color.RGBAModel
}

func (IMG Image) Bounds() image.Rectangle {
	return image.Rect(0, 0, 200, 200)
}

func (IMG Image) At(x, y int) color.Color {
	return color.RGBA{uint8(x), uint8(y), 255,255}
}

func main() {
	m := Image{100,100,200}
	pic.ShowImage(m)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang中的map和闭包</title>
      <link>http://moonsn.com/post/golang_2/</link>
      <pubDate>Wed, 21 Oct 2015 14:56:57 +0800</pubDate>
      
      <guid>http://moonsn.com/post/golang_2/</guid>
      <description>

&lt;h3 id=&#34;range:69277b731da08b89fa256107618093a3&#34;&gt;Range&lt;/h3&gt;

&lt;p&gt;range可以对slice或者map进行迭代循环&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
    for i, v := range pow {
        fmt.Printf(&amp;quot;2**%d = %d\n&amp;quot;, i, v)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;exercise-slices-go:69277b731da08b89fa256107618093a3&#34;&gt;exercise-slices.go&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;golang.org/x/tour/pic&amp;quot;

func Pic(dx, dy int) [][]uint8 {
    pic := make([][]uint8, dy);
    for y := range pic {
        pic[y] = make([]uint8, dx)
        for x := range pic[y] {
            pic[y][x] = uint8((x+y)/2)
        }
    }
    return pic
}

func main() {
    pic.Show(Pic)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;map:69277b731da08b89fa256107618093a3&#34;&gt;map&lt;/h3&gt;

&lt;p&gt;map在使用前必须用&lt;code&gt;make&lt;/code&gt;来创建.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
    Lat, Long float64
}

var m map[string]Vertex

func main() {
    m = make(map[string]Vertex)
    m[&amp;quot;Bell Labs&amp;quot;] = Vertex{
        40.68433, -74.39967,
    }
    fmt.Println(m[&amp;quot;Bell Labs&amp;quot;])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
    Lat, Long float64
}

var m = map[string]Vertex{
    &amp;quot;Bell Labs&amp;quot;: Vertex{
        40.68433, -74.39967,
    },
    &amp;quot;Google&amp;quot;: Vertex{
        37.42202, -122.08408,
    },
}

func main() {
    fmt.Println(m)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插入或修改一个元素：&lt;code&gt;m[key] = elem&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;获取元素：&lt;code&gt;elem = m[key]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;删除元素：&lt;code&gt;delete(m, key)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;通过双赋值检查某个键是否存在：&lt;code&gt;elem, ok = m[key]&lt;/code&gt;
存在ok为true&lt;/p&gt;

&lt;h3 id=&#34;exercise-map-go:69277b731da08b89fa256107618093a3&#34;&gt;exercise-map.go&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;code.google.com/p/go-tour/wc&amp;quot;
    &amp;quot;strings&amp;quot;
)

func WordCount(s string) map[string]int {
    word_list := strings.Fields(s)
    m := make(map[string]int)
    for _, value := range word_list {
        m[value] ++
    }
    return m
}

func main() {
    wc.Test(WordCount)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;func-value:69277b731da08b89fa256107618093a3&#34;&gt;func value&lt;/h3&gt;

&lt;p&gt;函数也可以当做值赋给变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;math&amp;quot;
)

func main() {
    hypot := func(x, y float64) float64 {
        return math.Sqrt(x*x + y*y)
    }

    fmt.Println(hypot(3, 4))
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;闭包:69277b731da08b89fa256107618093a3&#34;&gt;闭包&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func adder() func(int) int {
    sum := 0
    return func(x int) int {
        sum += x
        return sum
    }
}

func main() {
    pos, neg := adder(), adder()
    for i := 0; i &amp;lt; 10; i++ {
        fmt.Println(
            pos(i),
            neg(-2*i),
        )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用闭包输出斐波那契数列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

// fibonacci 函数会返回一个返回 int 的函数。
func fibonacci() func() int {
    a, b := 0, 1
    return func() int {
        a = a + b
        a, b = b, a
        return a
    }
}

func main() {
    f := fibonacci()
    for i := 0; i &amp;lt; 10; i++ {
        fmt.Println(f())
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang中的Slice</title>
      <link>http://moonsn.com/post/golangslice/</link>
      <pubDate>Wed, 21 Oct 2015 14:17:10 +0800</pubDate>
      
      <guid>http://moonsn.com/post/golangslice/</guid>
      <description>

&lt;h3 id=&#34;what:90cfd4505499368a99e1f321bbb29b12&#34;&gt;What?&lt;/h3&gt;

&lt;p&gt;Slice(切片)可以看做是包含三个属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;指向数组的指针&lt;/li&gt;
&lt;li&gt;切片的长度&lt;/li&gt;
&lt;li&gt;切片的容量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用[]来访问切片，len函数可以返回切片的长度，cap函数可以返回切片的容量。&lt;/p&gt;

&lt;h3 id=&#34;how-to-creat-it:90cfd4505499368a99e1f321bbb29b12&#34;&gt;How To Creat It?&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;s := make([]int, 10) // len(s) = 10, cap(s) = 10
or
s := []int{1, 2, 3, 4, 5} //len(s) = 5, cap(s) = 5
or 
var a [10]int
s := a[1:5] //len(s) = 4, cap(s) = 10, same as make([]int, 4, 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当数组a改变是，切片也会变。切片的操作也会影响数组&lt;/p&gt;

&lt;h3 id=&#34;some-else:90cfd4505499368a99e1f321bbb29b12&#34;&gt;Some else!&lt;/h3&gt;

&lt;p&gt;append函数可以在slice后面加元素。这这时会为slice重新分配空间。如果之前是指向某个数组的，那么，append会使关系失效。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    var a = [...]int{1,2,3,4,5}
    z := a[1:4]
    fmt.Println(a)//[1 2 3 4 5]
    fmt.Println(z)//[2 3 4]
    z[2] = 3
    fmt.Println(a)//[1 2 3 3 5]
    fmt.Println(z)//[2 3 3]
    z = append(z,6,7)
    fmt.Println(a)//[1 2 3 3 5]
    fmt.Println(z)//[2 3 3 6 7]
    a[0] = 10
    fmt.Println(a)//[10 2 3 3 5]
    fmt.Println(z)//[2 3 3 6 7]
    z[0] = 20
    fmt.Println(a)//[10 2 3 3 5]
    fmt.Println(z)//[20 3 3 6 7]
    s := a[0:3]
    z = append(z, s...)
    fmt.Println(z)//[20 3 3 6 7 10 2 3]
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang的结构，基本类型及语法</title>
      <link>http://moonsn.com/post/aboutgolang/</link>
      <pubDate>Wed, 21 Oct 2015 11:00:08 +0800</pubDate>
      
      <guid>http://moonsn.com/post/aboutgolang/</guid>
      <description>

&lt;p&gt;golang需要指定一个工作目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;▾ workspace
    ▾ src (用于存放go源码)
    ▾ pkg (放包)
    ▾ bin (编译出来的东西会放到这里)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go源码文件的第一行必须是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你import一个package的时候，他会解析出目录最后一个元素作为包名，以便在代码中使用。&lt;/p&gt;

&lt;h3 id=&#34;testing:e8844f493f37509013ac5e563f59eb18&#34;&gt;Testing&lt;/h3&gt;

&lt;p&gt;go有一个轻量级的测试框架。go test 命令和testing 包&lt;/p&gt;

&lt;p&gt;你只需要建立一个以_test.go结尾的文件,go test 会运行里面的所有TestXXX函数（这些函数是参数是 &lt;code&gt;(t *testing.T)&lt;/code&gt;)，如果函数调用了&lt;code&gt;t.Error&lt;/code&gt;或&lt;code&gt;t.Fail&lt;/code&gt;，就认为测试失败。&lt;/p&gt;

&lt;p&gt;我们给stringutil添加一个测试:&lt;/p&gt;

&lt;h4 id=&#34;gopath-src-github-com-moonsn-stringutil-reverse-test-go:e8844f493f37509013ac5e563f59eb18&#34;&gt;$GOPATH/src/github.com/moonsn/stringutil/reverse_test.go&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package stringutil

import &amp;quot;testing&amp;quot;

func TestReverse(t *testing.T) {
    cases := []struct {
        in, want string
    }{
        {&amp;quot;Hello, world&amp;quot;, &amp;quot;dlrow ,olleH&amp;quot;},
        {&amp;quot;Hello, 世界&amp;quot;, &amp;quot;界世 ,olleH&amp;quot;}
        {&amp;quot;&amp;quot;,&amp;quot;&amp;quot;}
    }
    for _, c := range cases {
        got := Reverse(c.in)
        if got != c.want {
            t.Errorf(&amp;quot;Reverse(%q) == %q, want %q&amp;quot;, c.in, got, c.want)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行test&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go test
ok      github.com/user/stringutil 0.165s
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;remote-package:e8844f493f37509013ac5e563f59eb18&#34;&gt;Remote Package&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/golang/example/hello
$ $GOPATH/bin/hello
Hello, Go example!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;go get&lt;/code&gt;会自动fetch,build,insatll&lt;/p&gt;

&lt;h3 id=&#34;func:e8844f493f37509013ac5e563f59eb18&#34;&gt;func&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func swap(x, y string) (string, string) {
    return y, x
}

func main() {
    a, b := swap(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;)
    fmt.Println(a, b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;函数参数类型在变量名之后，多个相同的连续类型可以只写最后一个。&lt;/li&gt;
&lt;li&gt;返回值类型写在参数列表之后。&lt;/li&gt;
&lt;li&gt;函数可以返回任意多个返回值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;var:e8844f493f37509013ac5e563f59eb18&#34;&gt;var&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

var i, j int = 1, 2

func main() {
    var c, python, java = true, false, &amp;quot;no!&amp;quot;
    k := 3
    fmt.Println(i, j, c, python, java)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;var 语句定义了一个变量的列表；跟函数的参数列表一样，类型在后面。&lt;/li&gt;
&lt;li&gt;就像在这个例子中看到的一样， var 语句可以定义在包或函数级别。&lt;/li&gt;
&lt;li&gt;变量定义可以包含初始值，每个变量对应一个。&lt;/li&gt;
&lt;li&gt;如果初始化是使用表达式，则可以省略类型；变量从初始值中获得类型。&lt;/li&gt;
&lt;li&gt;在函数中， := 简洁赋值语句在明确类型的地方，可以用于替代 var 定义。&lt;/li&gt;
&lt;li&gt;函数外的每个语句都必须以关键字开始（ var 、 func 、等等）， := 结构不能使用在函数外。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;基本类型:e8844f493f37509013ac5e563f59eb18&#34;&gt;基本类型&lt;/h3&gt;

&lt;p&gt;Go 的基本类型有Basic types&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8 的别名

rune // int32 的别名
     // 代表一个Unicode码

float32 float64

complex64 complex128
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;math/cmplx&amp;quot;
)

//可以像这样定义变量
var (
    ToBe   bool       = false
    MaxInt uint64     = 1&amp;lt;&amp;lt;64 - 1
    z      complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
    const f = &amp;quot;%T(%v)\n&amp;quot; //T 类型 v变量
    fmt.Printf(f, ToBe, ToBe)
    fmt.Printf(f, MaxInt, MaxInt)
    fmt.Printf(f, z, z)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;for:e8844f493f37509013ac5e563f59eb18&#34;&gt;for&lt;/h3&gt;

&lt;p&gt;Go 只有一种循环结构—— for 循环。&lt;/p&gt;

&lt;p&gt;基本的 for 循环除了没有了 ( ) 之外（甚至强制不能使用它们），看起来跟 C 或者 Java 中做的一样，而 { } 是必须的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    sum := 0
    for i := 0; i &amp;lt; 10; i++ {
        sum += i
    }
    fmt.Println(sum)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;where:e8844f493f37509013ac5e563f59eb18&#34;&gt;where ?&lt;/h3&gt;

&lt;p&gt;like this!!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    sum := 1
    for sum &amp;lt; 1000 { //while(sum&amp;lt;1000)
        sum += sum
    }
    fmt.Println(sum)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;那么全省略的话:e8844f493f37509013ac5e563f59eb18&#34;&gt;那么全省略的话？？&lt;/h3&gt;

&lt;p&gt;当然是无限循环了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

func main() {
    for {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;if:e8844f493f37509013ac5e563f59eb18&#34;&gt;if&lt;/h3&gt;

&lt;p&gt;和for一样，省略了括号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;math&amp;quot;
)

func sqrt(x float64) string {
    if x &amp;lt; 0 {
        return sqrt(-x) + &amp;quot;i&amp;quot;
    }
    return fmt.Sprint(math.Sqrt(x))
}

func main() {
    fmt.Println(sqrt(2), sqrt(-4))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一样的地方还有：可以在条件前面定义一个局部变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;math&amp;quot;
)

func pow(x, n, lim float64) float64 {
    if v := math.Pow(x, n); v &amp;lt; lim {
        return v
    }
    return v;
}

func main() {
    fmt.Println(
        pow(3, 2, 10),
        pow(3, 3, 20),
    )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;defer:e8844f493f37509013ac5e563f59eb18&#34;&gt;defer&lt;/h3&gt;

&lt;p&gt;defer会延迟函数的执行，指导上层函数返回。（defer 的函数会执行并要入一个栈中）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    fmt.Println(&amp;quot;counting&amp;quot;)

    for i := 0; i &amp;lt; 10; i++ {
        defer fmt.Println(i)
    }

    fmt.Println(&amp;quot;done&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;指针:e8844f493f37509013ac5e563f59eb18&#34;&gt;指针&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var p *int;
i := 42
p = &amp;amp;i
fmt.Println(*p);//42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用法同c语言，但是没有指针运算。&lt;/p&gt;

&lt;h3 id=&#34;结构体:e8844f493f37509013ac5e563f59eb18&#34;&gt;结构体&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
    X int
    Y int
}

func main() {
    v := Vertex{1, 2}
    p := &amp;amp;v
    p.X = 1e9
    fmt.Println(v)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;数组:e8844f493f37509013ac5e563f59eb18&#34;&gt;数组&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var arr [10]int
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>为Hugo的文章页创建模板</title>
      <link>http://moonsn.com/post/hugo-single/</link>
      <pubDate>Tue, 20 Oct 2015 22:29:32 +0800</pubDate>
      
      <guid>http://moonsn.com/post/hugo-single/</guid>
      <description>

&lt;p&gt;single 是最主要的视图，Hugo会为每个Markdown文件提供一个single模板来渲染。&lt;/p&gt;

&lt;h2 id=&#34;会用哪个模板来渲染呢:e6d3cde5b499b420f687e97496609c42&#34;&gt;会用哪个模板来渲染呢？&lt;/h2&gt;

&lt;p&gt;Hugo 用一系列的规则来推测应该用哪个模板类渲染一个页面。&lt;/p&gt;

&lt;p&gt;Hugo 选择模板的优先级如下表。如果一个文件不存在，那么下一个会被使用。这使得你可以为更多的页面设计模板。但多数情况下,列表最后的&lt;code&gt;_default&lt;/code&gt; 文件就够啦。&lt;/p&gt;

&lt;p&gt;用户可以在&lt;code&gt;front-matter&lt;/code&gt;部分定义&lt;code&gt;type&lt;/code&gt; 和&lt;code&gt;layout&lt;/code&gt;指定用哪个模板渲染。&lt;code&gt;Section&lt;/code&gt;是由md文件所在的位置来确定的。当然，如果你指定了&lt;code&gt;type&lt;/code&gt;，那么还是以&lt;code&gt;type&lt;/code&gt;为准。&lt;/p&gt;

&lt;h3 id=&#34;single:e6d3cde5b499b420f687e97496609c42&#34;&gt;Single&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;/layouts/TYPE-or-SECTION/LAYOUT.html&lt;/li&gt;
&lt;li&gt;/layouts/TYPE-or-SECTION/single.html&lt;/li&gt;
&lt;li&gt;/layouts/_default/single.html&lt;/li&gt;
&lt;li&gt;/themes/THEME/layouts/TYPE-or-SECTION/LAYOUT.html&lt;/li&gt;
&lt;li&gt;/themes/THEME/layouts/TYPE-or-SECTION/single.html&lt;/li&gt;
&lt;li&gt;/themes/THEME/layouts/_default/single.html&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;模板示例:e6d3cde5b499b420f687e97496609c42&#34;&gt;模板示例&lt;/h2&gt;

&lt;p&gt;md页面是&amp;rsquo;page&amp;rsquo;类型的，在他的模板中可以使用所有&lt;code&gt;page variables&lt;/code&gt;和&lt;code&gt;site variable&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;下面我们将造着默认的模板，创建两个不同的类型的模板。&lt;/p&gt;

&lt;p&gt;默认模板会在没有指定type是使用，他的工作原理和其他模板是一样的，但是他必须在&amp;rdquo;_default&amp;rdquo;目录下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;▾ layouts/
	▾ _default/
		single.html
	▾ post/
		single.html
	▾ project/
		single.html
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;post-single-html:e6d3cde5b499b420f687e97496609c42&#34;&gt;post/single.html&lt;/h3&gt;

&lt;p&gt;这个模板是&lt;a href=&#34;http://spf13.com&#34;&gt;spf13.com&lt;/a&gt;在使用的模板。他用到了&lt;code&gt;partial templates&lt;/code&gt;(也就是模板引用)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ partial &amp;quot;header.html&amp;quot; . }}
{{ partial &amp;quot;subheader.html&amp;quot; . }}
{{ $baseurl := .Site.BaseURL }}

&amp;lt;section id=&amp;quot;main&amp;quot;&amp;gt;
  &amp;lt;h1 id=&amp;quot;title&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/h1&amp;gt;
  &amp;lt;div&amp;gt;
        &amp;lt;article id=&amp;quot;content&amp;quot;&amp;gt;
           {{ .Content }}
        &amp;lt;/article&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/section&amp;gt;

&amp;lt;aside id=&amp;quot;meta&amp;quot;&amp;gt;
    &amp;lt;div&amp;gt;
    &amp;lt;section&amp;gt;
      &amp;lt;h4 id=&amp;quot;date&amp;quot;&amp;gt; {{ .Date.Format &amp;quot;Mon Jan 2, 2006&amp;quot; }} &amp;lt;/h4&amp;gt;
      &amp;lt;h5 id=&amp;quot;wc&amp;quot;&amp;gt; {{ .FuzzyWordCount }} Words &amp;lt;/h5&amp;gt;
    &amp;lt;/section&amp;gt;
    &amp;lt;ul id=&amp;quot;categories&amp;quot;&amp;gt;
      {{ range .Params.topics }}
        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{{ $baseurl }}/topics/{{ . | urlize }}&amp;quot;&amp;gt;{{ . }}&amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt;
      {{ end }}
    &amp;lt;/ul&amp;gt;
    &amp;lt;ul id=&amp;quot;tags&amp;quot;&amp;gt;
      {{ range .Params.tags }}
        &amp;lt;li&amp;gt; &amp;lt;a href=&amp;quot;{{ $baseurl }}/tags/{{ . | urlize }}&amp;quot;&amp;gt;{{ . }}&amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt;
      {{ end }}
    &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;
        {{ if .Prev }}
          &amp;lt;a class=&amp;quot;previous&amp;quot; href=&amp;quot;{{.Prev.Permalink}}&amp;quot;&amp;gt; {{.Prev.Title}}&amp;lt;/a&amp;gt;
        {{ end }}
        {{ if .Next }}
          &amp;lt;a class=&amp;quot;next&amp;quot; href=&amp;quot;{{.Next.Permalink}}&amp;quot;&amp;gt; {{.Next.Title}}&amp;lt;/a&amp;gt;
        {{ end }}
    &amp;lt;/div&amp;gt;
&amp;lt;/aside&amp;gt;

{{ partial &amp;quot;disqus.html&amp;quot; . }}
{{ partial &amp;quot;footer.html&amp;quot; . }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;project-single-html:e6d3cde5b499b420f687e97496609c42&#34;&gt;project/single.html&lt;/h3&gt;

&lt;p&gt;这个模板是&lt;a href=&#34;http://spf13.com&#34;&gt;spf13.com&lt;/a&gt;在使用的模板。他用到了&lt;code&gt;partial templates&lt;/code&gt;(也就是模板引用)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ partial &amp;quot;header.html&amp;quot; . }}
{{ partial &amp;quot;subheader.html&amp;quot; . }}
{{ $baseurl := .Site.BaseURL }}

&amp;lt;section id=&amp;quot;main&amp;quot;&amp;gt;
  &amp;lt;h1 id=&amp;quot;title&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/h1&amp;gt;
  &amp;lt;div&amp;gt;
        &amp;lt;article id=&amp;quot;content&amp;quot;&amp;gt;
           {{ .Content }}
        &amp;lt;/article&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/section&amp;gt;

&amp;lt;aside id=&amp;quot;meta&amp;quot;&amp;gt;
    &amp;lt;div&amp;gt;
    &amp;lt;section&amp;gt;
      &amp;lt;h4 id=&amp;quot;date&amp;quot;&amp;gt; {{ .Date.Format &amp;quot;Mon Jan 2, 2006&amp;quot; }} &amp;lt;/h4&amp;gt;
      &amp;lt;h5 id=&amp;quot;wc&amp;quot;&amp;gt; {{ .FuzzyWordCount }} Words &amp;lt;/h5&amp;gt;
    &amp;lt;/section&amp;gt;
    &amp;lt;ul id=&amp;quot;categories&amp;quot;&amp;gt;
      {{ range .Params.topics }}
      &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{{ $baseurl }}/topics/{{ . | urlize }}&amp;quot;&amp;gt;{{ . }}&amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt;
      {{ end }}
    &amp;lt;/ul&amp;gt;
    &amp;lt;ul id=&amp;quot;tags&amp;quot;&amp;gt;
      {{ range .Params.tags }}
        &amp;lt;li&amp;gt; &amp;lt;a href=&amp;quot;{{ $baseurl }}/tags/{{ . | urlize }}&amp;quot;&amp;gt;{{ . }}&amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt;
      {{ end }}
    &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/aside&amp;gt;

{{if isset .Params &amp;quot;project_url&amp;quot; }}
&amp;lt;div id=&amp;quot;ribbon&amp;quot;&amp;gt;
    &amp;lt;a href=&amp;quot;{{ index .Params &amp;quot;project_url&amp;quot; }}&amp;quot; rel=&amp;quot;me&amp;quot;&amp;gt;Fork me on GitHub&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
{{ end }}

{{ partial &amp;quot;footer.html&amp;quot; . }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，上面的project/single.html中使用了只对这个模板起作用的附加参数。他不需要提前定义，如果这个参数在&lt;code&gt;fornt-matter&lt;/code&gt;中定义了的话就能在模板中使用他。&lt;/p&gt;

&lt;p&gt;当然，你可以用&lt;code&gt;content archetypes&lt;/code&gt;来快速生成这类模板对应的主题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>about</title>
      <link>http://moonsn.com/about/</link>
      <pubDate>Tue, 20 Oct 2015 17:55:24 +0800</pubDate>
      
      <guid>http://moonsn.com/about/</guid>
      <description></description>
    </item>
    
    <item>
      <title>std::move()将左值转化为右值</title>
      <link>http://moonsn.com/post/welcome/</link>
      <pubDate>Tue, 20 Oct 2015 16:38:57 +0800</pubDate>
      
      <guid>http://moonsn.com/post/welcome/</guid>
      <description>

&lt;p&gt;this is summary?&lt;/p&gt;

&lt;h2 id=&#34;header:2cc7dc244eed4480e8b46c91e911e96b&#34;&gt;header&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;std::move()功能强大啊&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void ProcessValue(int&amp;amp; i) { 
		std::cout &amp;lt;&amp;lt; &amp;quot;LValue processed: &amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; 
} 

void ProcessValue(int&amp;amp;&amp;amp; i) { 
		std::cout &amp;lt;&amp;lt; &amp;quot;RValue processed: &amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; 
} 

int main() { 
  		int a = 0; 
  		ProcessValue(a); 
  		ProcessValue(std::move(a)); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看看在swap的时候，省了3次copy&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;class T&amp;gt; swap(T&amp;amp; a, T&amp;amp; b) 
    { 
        T tmp(std::move(a)); // move a to tmp 
        a = std::move(b);    // move b to a 
        b = std::move(tmp);  // move tmp to b 
 }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>选择Hugo作为博客生成器</title>
      <link>http://moonsn.com/post/first/</link>
      <pubDate>Tue, 20 Oct 2015 16:38:50 +0800</pubDate>
      
      <guid>http://moonsn.com/post/first/</guid>
      <description>&lt;p&gt;最近读书很多，感悟也很多。此刻明白我那失去多年的博客该重新上阵了。
一直在寻找一个简单易用的博客，WordPress太过臃肿了。&lt;/p&gt;

&lt;p&gt;google static blog.发现了Hugo这个好东西。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hugo 是19世纪法国积极浪漫主义作家&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;它配置简单（在不自制主题的情况下）&lt;/li&gt;
&lt;li&gt;用golang编写的，仅仅需要一个二进制文件就可以生成静态博客&lt;/li&gt;
&lt;li&gt;作为google粉，用golang语言的东西（渲染模板是golang的）感觉很棒&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>