<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>moonsn&#39;s profile</title>
    <link>http://moonsn.com/</link>
    <description>Recent content on moonsn&#39;s profile</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Sun, 01 May 2016 16:34:01 +0800</lastBuildDate>
    <atom:link href="http://moonsn.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>eol教务系统课表导出到ical格式</title>
      <link>http://moonsn.com/projects/eolical/</link>
      <pubDate>Sun, 01 May 2016 16:34:01 +0800</pubDate>
      
      <guid>http://moonsn.com/projects/eolical/</guid>
      <description>&lt;p&gt;这是&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>《STL源码剖析》读书笔记</title>
      <link>http://moonsn.com/books/stlread/</link>
      <pubDate>Mon, 18 Apr 2016 13:42:01 +0800</pubDate>
      
      <guid>http://moonsn.com/books/stlread/</guid>
      <description>

&lt;h2 id=&#34;迭代器的设计:2e660a4f3b4029d33da97197f6320630&#34;&gt;迭代器的设计&lt;/h2&gt;

&lt;h4 id=&#34;1-迭代器-iterator-模式在-design-patterns-中是这么定义的:2e660a4f3b4029d33da97197f6320630&#34;&gt;1. 迭代器&lt;code&gt;iterator&lt;/code&gt;模式在《Design Patterns》中是这么定义的：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;提供一直方法，使之能够依序巡防某个聚合物所含的各个元素，而又无线暴露该聚合物的
内部表述方式。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-获取迭代器所指对象的型别:2e660a4f3b4029d33da97197f6320630&#34;&gt;2. 获取迭代器所指对象的型别&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;template &amp;lt;class I, class T&amp;gt;
void func_impl(I iter, T t)
{
    T tmp;
}

template &amp;lt;class I&amp;gt;
inline
void func(I iter) {
 func_impl(iter, *iter)
}

int main() {
    int i;
    func(&amp;amp;i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里利用&lt;code&gt;function template&lt;/code&gt;的参数推导机制获取迭代器的相应型别。&lt;/p&gt;

&lt;h4 id=&#34;3-traits-技巧:2e660a4f3b4029d33da97197f6320630&#34;&gt;3. Traits 技巧&lt;/h4&gt;

&lt;p&gt;由于&lt;code&gt;function template&lt;/code&gt;推导的是模板参数，无法推导函数的返回值型别、
所以用 声明内嵌型别的方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template &amp;lt;class T&amp;gt;
struct MyIter {
    typedef T value_type;
    T* ptr;
    MyIter(T* p = 0) : ptr(p) {}
    T&amp;amp; operator*() const { return *ptr; }
}

template &amp;lt;class I&amp;gt;
tpyename I::value_type
func(I ite) {
    return *ite;
}

MyIter&amp;lt;int&amp;gt; ite(new int(8));
cout &amp;lt;&amp;lt; func(ite); // print: 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;又由于内嵌型别只能用于&lt;code&gt;class type&lt;/code&gt;，对于原生指针又无法支持。所以需要用到
&lt;code&gt;template partial specialization&lt;/code&gt;模板偏特化来对原生指针做支持&lt;/p&gt;

&lt;p&gt;利用了偏特化的方式我们提取迭代器&lt;code&gt;value type&lt;/code&gt;就可以这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template &amp;lt;class I&amp;gt;
struct iterator_traits {
    typedef typename I::value_type value_type;
}

template &amp;lt;class T&amp;gt;
struct iterator_traits&amp;lt;T*&amp;gt; { //偏特化版本，迭代器是原生指针
    typedef T value_type;
}

//同样的，对const int *，提取int
//即：对const T*,我们提取类型为T
template &amp;lt;class T&amp;gt;
struct iterator_traits&amp;lt;const T*&amp;gt; {
    typedef T value_type;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;4-迭代器分类:2e660a4f3b4029d33da97197f6320630&#34;&gt;4. 迭代器分类&lt;/h4&gt;

&lt;p&gt;根据移动特性和施行操作，迭代器被分为五类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Input Iterator: 所指对象只读。支持++操作&lt;/li&gt;
&lt;li&gt;Output Iterator: Write Only.支持++操作&lt;/li&gt;
&lt;li&gt;Forward Iterator: 允许写入。支持++操作&lt;/li&gt;
&lt;li&gt;Bidirectional Iterator: 可双向移动。&lt;/li&gt;
&lt;li&gt;Random Access Iterator:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;利用重载函数来对同一个算法的不同类型迭代器做不同的操作，定义相应的五种迭代器结构.
在&lt;code&gt;traits&lt;/code&gt;里加入一条&lt;code&gt;iterator_category&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template &amp;lt;class I&amp;gt;
struct iterator_traits {
    ...
    typedef typename I::iterator_category iterator_category;
}
//还需要对原生指针进行偏特化处理


//在算法中就这样使用，来激发函数重载机制(编译时期).
template &amp;lt;class I, class Distance&amp;gt;
inline void advance(I&amp;amp; i, Distance n) {
    __advance(i, n, iterator_traits&amp;lt;I&amp;gt;::iterator_category());//做对应的操作
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;5-stl-iterator:2e660a4f3b4029d33da97197f6320630&#34;&gt;5. stl::iterator&lt;/h4&gt;

&lt;p&gt;STL为我们提供了一个&lt;code&gt;iterator class&lt;/code&gt;我们的迭代器继承它就能符合stl的标准了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template &amp;lt;class Item&amp;gt;
struct ListIter : public std::iterator&amp;lt;std::forward_iterator_tag, Item&amp;gt; { ... };
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Unix I/O</title>
      <link>http://moonsn.com/post/stdio/</link>
      <pubDate>Tue, 15 Dec 2015 13:43:41 +0800</pubDate>
      
      <guid>http://moonsn.com/post/stdio/</guid>
      <description>

&lt;p&gt;使用标准IO的一个优点是不用考虑缓冲和最佳IO长度问题&lt;/p&gt;

&lt;h2 id=&#34;缓冲:aeb762551f39a1799063c0291b6b6e61&#34;&gt;缓冲&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;全缓冲&lt;/li&gt;
&lt;li&gt;行缓冲&lt;/li&gt;
&lt;li&gt;不带缓冲&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;int fflush(FILE *fp);//可以强制冲洗缓冲区
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;打开流:aeb762551f39a1799063c0291b6b6e61&#34;&gt;打开流&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;FILE *fopen(const char *restrict pathname, const char *restrict type);
FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);
FILE *fdopen(int fd, const char *type);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;int fclose(FILE *fp);//关闭流
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;读写流:aeb762551f39a1799063c0291b6b6e61&#34;&gt;读写流&lt;/h2&gt;

&lt;h3 id=&#34;按字符:aeb762551f39a1799063c0291b6b6e61&#34;&gt;按字符&lt;/h3&gt;

&lt;p&gt;读：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int getc(FILE *fp);
int fgetc(FILE *fp);
int getchar(void); // 相当于getc(STDIN);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值得注意的是，不管是出错还是到文件结尾，3个函数返回值都相同。区别这两种情况，必须调用&lt;code&gt;ferror&lt;/code&gt;或&lt;code&gt;feof&lt;/code&gt;;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int main(){
    int c;
    while((c = getc(stdin)) != EOF) {
        if (putc(c, stdout) == EOF) {
            fprintf(stderr, &amp;quot;output error&amp;quot;);
        }
    }

    if (ferror(stdin)) { //判断是EOF还是error
        fprintf(stderr, &amp;quot;input error&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int putc(int c, FILE *fp);
int fputc(int c, FILE *fp);
int putchar(int c);//相当于putc(c, stdout);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;按行:aeb762551f39a1799063c0291b6b6e61&#34;&gt;按行&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;char *fgets(char *restrict buf, int n, FILE *restrict fp);
char *gets(char *buf); //不考虑缓冲区长度读，可能溢出
char fputs(const char *restrict str, FILE *restrict fp);
int puts(const char *str);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;二进制io:aeb762551f39a1799063c0291b6b6e61&#34;&gt;二进制IO&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写一个结构到文件中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct {
    short count;
    long total;
    char name[NAMESIZE];
} item;

if (fwirte(&amp;amp;item, sizeof(item), 1, fp) != 1) {
    fprintf(stderr, &amp;quot;fwirte error&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>producer consumer problem implement with Go</title>
      <link>http://moonsn.com/post/producer-consumer/</link>
      <pubDate>Tue, 01 Dec 2015 13:43:41 +0800</pubDate>
      
      <guid>http://moonsn.com/post/producer-consumer/</guid>
      <description>&lt;p&gt;&lt;code&gt;生产者消费者问题&lt;/code&gt;(&lt;a href=&#34;https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem&#34;&gt;Producer–consumer problem&lt;/a&gt;)是一个典型的并发问题，生产者产生数据，同时消费者也在&lt;code&gt;消费&lt;/code&gt;数据。&lt;/p&gt;

&lt;p&gt;Go的特点就是并发性，所以实现这个问题对go来说很轻松。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main
import &amp;quot;fmt&amp;quot;

var done = make(chan bool)
var products = make(chan int)

func producer() {
    for i := 0; i &amp;lt; 10; i++ {
        products &amp;lt;- i
        fmt.Println(i, &amp;quot; produced!&amp;quot;)
    }
    done &amp;lt;- true
}

func consumer() {
    for {
        product := &amp;lt;- products
        fmt.Println(product, &amp;quot; consumed!&amp;quot;)
    }
}

func main() {
    go producer();
    go consumer();
    &amp;lt;- done
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>运算符重载中的问题</title>
      <link>http://moonsn.com/post/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 08 Nov 2015 15:53:52 +0800</pubDate>
      
      <guid>http://moonsn.com/post/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;我们知道c++的运算符是可以重载的(个别除外)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class A{};
A&amp;amp; operator,(A&amp;amp;, A&amp;amp;); //重载了逗号运算符
bool operator&amp;amp;&amp;amp;(A&amp;amp;, A&amp;amp;); //重载了&amp;amp;&amp;amp;运算符

A b1, b2;

if (b1&amp;amp;&amp;amp;b2) b1, b2; // if(operator&amp;amp;&amp;amp;(b1, b2)) operator,(b1,b2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，重载了运算符之后，对运算符的使用被替换为相应的函数调用形式。因此，旧有的运算符的执行顺序不再适用，取而代之的是函数参数的压栈顺序。&lt;/p&gt;

&lt;p&gt;短路语义只是一个方面，更重要的在于压栈顺序。鉴于执行效率和旧代码兼容性等细节问题，C++标准在压栈顺序上给编译器的开发者留有很大自主性。标准的说辞是，编译器可能以任何它觉得方便的顺序将参数压栈，从左到右，从右到左，甚至从中间到两边，在这一点上我们不能安全地做任何假设。在上面的例子中，编译器生成的代码可能先计算b1再计算b2，也可能是相反的顺序。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;少用为妙~~~&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>jQuery Tips</title>
      <link>http://moonsn.com/post/jquery_tips/</link>
      <pubDate>Sun, 08 Nov 2015 12:27:01 +0800</pubDate>
      
      <guid>http://moonsn.com/post/jquery_tips/</guid>
      <description>&lt;p&gt;昨天这做了轮播，网速跟不上的话，会很难看。。
今天发现这个小技巧~记上！&lt;/p&gt;

&lt;p&gt;图片预加载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.preloadImages = function () {
  for (var i = 0; i &amp;lt; arguments.length; i++) {
    $(&#39;&amp;lt;img&amp;gt;&#39;).attr(&#39;src&#39;, arguments[i]);
  }
};

$.preloadImages(&#39;img/hover-on.png&#39;, &#39;img/hover-off.png&#39;);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Thread</title>
      <link>http://moonsn.com/post/thread/</link>
      <pubDate>Wed, 04 Nov 2015 15:10:00 +0800</pubDate>
      
      <guid>http://moonsn.com/post/thread/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;前段时间看了golang.并行的模块停下来了，正好这个学期上操作系统，而且前段时间的五子棋设计的时候需要网络通信。多线程就成了必要的东西的了。是时候看看线程了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在没有设计多线程之前，我们的程序是step by step的！&lt;/p&gt;

&lt;p&gt;大程序往往会由许许多多的小程序组成，例如，Web服务器需要处理从浏览器发来的请求，并回复HTML页面。每个请求就像一个小程序。
web服务器能同时处理多个请求，这就需要并行的技术了。&lt;/p&gt;

&lt;p&gt;在java中要使一个类的几个示例多线程运行，则类需要继承自&lt;code&gt;Runnable&lt;/code&gt;类。然后用 &lt;code&gt;Thread&lt;/code&gt;类来创建进程。(当然还有其他的方式).&lt;/p&gt;

&lt;p&gt;在Go中，用&lt;code&gt;goroutines&lt;/code&gt; 和 &lt;code&gt;channels&lt;/code&gt;来支持并行.&lt;/p&gt;

&lt;h2 id=&#34;goroutines:8f9474acbe8eccfc75abfaabcbdf5ffa&#34;&gt;Goroutines&lt;/h2&gt;

&lt;p&gt;对于&lt;code&gt;goroutines&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A goroutine is a function that is capable of running concurrently with other functions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;要新建一个&lt;code&gt;goroutine&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;
import &amp;quot;time&amp;quot;

func f(n int) {
	for i := 0; i &amp;lt; 10; i++ {
		fmt.Println(n, &amp;quot;:&amp;quot;, i)
		time.Sleep(time.Millisecond * 1000)
	}
}

func main() {
	go f(0)
	var input string
	fmt.Scanln(&amp;amp;input)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码中有两个&lt;code&gt;goroutine&lt;/code&gt;。第一个是个隐式的:&lt;code&gt;main&lt;/code&gt;函数本身。第二个是我们用&lt;code&gt;go f(0)&lt;/code&gt;创建的。
正常情况下，函数调用会执行完返回再进入下一行，但是有了&lt;code&gt;goroutine&lt;/code&gt;，会马上执行下一行，不用等到函数返回。&lt;/p&gt;

&lt;p&gt;这么看来，go语言的&lt;code&gt;goroutine&lt;/code&gt;比java中的轻量了许多。也方便了不少。&lt;/p&gt;

&lt;h2 id=&#34;channels:8f9474acbe8eccfc75abfaabcbdf5ffa&#34;&gt;channels&lt;/h2&gt;

&lt;p&gt;对于&lt;code&gt;channels&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Channels provide a way for two goroutines to communicate with one another and synchronize
their execution.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;time&amp;quot;
)

func pinger(c chan string) {
  for i := 0; ; i++ {
    c &amp;lt;- &amp;quot;ping&amp;quot;
  }
}

func printer(c chan string) {
  for {
    msg := &amp;lt;- c
    fmt.Println(msg)
    time.Sleep(time.Second * 1)
  }
}

func main() {
  var c chan string = make(chan string)

  go pinger(c)
  go printer(c)

  var input string
  fmt.Scanln(&amp;amp;input)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;channal的声明就不说了，我们可以当c时一个容器，这里是string容器。
printer会输出c里的内容,而pinger书不断往容器里放入&amp;rdquo;ping&amp;rdquo;。当容器是空的时候，printer就会阻塞了.&lt;/p&gt;

&lt;p&gt;对了,channel是可以有buffer大小的:&lt;code&gt;make(chan int , 3)&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;select:8f9474acbe8eccfc75abfaabcbdf5ffa&#34;&gt;select&lt;/h2&gt;

&lt;p&gt;这是&lt;code&gt;channel&lt;/code&gt;的switch。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
  c1 := make(chan string)
  c2 := make(chan string)

  go func() {
    for {
      c1 &amp;lt;- &amp;quot;from 1&amp;quot;
      time.Sleep(time.Second * 2)
    }
  }()

  go func() {
    for {
      c2 &amp;lt;- &amp;quot;from 2&amp;quot;
      time.Sleep(time.Second * 3)
    }
  }()

  go func() {
    for {
      select {
      case msg1 := &amp;lt;- c1:
        fmt.Println(msg1)
      case msg2 := &amp;lt;- c2:
        fmt.Println(msg2)
      }
    }
  }()

  var input string
  fmt.Scanln(&amp;amp;input)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>停电一天</title>
      <link>http://moonsn.com/post/nowifi/</link>
      <pubDate>Mon, 26 Oct 2015 21:41:17 +0800</pubDate>
      
      <guid>http://moonsn.com/post/nowifi/</guid>
      <description>&lt;p&gt;全校电力检修，没有电没有网。这种日子就应该11点起，1点睡午觉，4点起，看会儿书。&lt;/p&gt;

&lt;p&gt;5点，wow来点了。。。。&lt;/p&gt;

&lt;p&gt;6点，操作系统课&lt;/p&gt;

&lt;p&gt;内存分配方案，最好的还是在std里的内存分配机制。分类检索分配!&lt;/p&gt;

&lt;p&gt;水一下~~&lt;/p&gt;

&lt;p&gt;更&lt;/p&gt;

&lt;p&gt;昨天重构了一下五子棋的代码，然而，就在最后一刻手贱把代码给删了。。。。&lt;/p&gt;

&lt;p&gt;回到前天的版本。。。。&lt;/p&gt;

&lt;p&gt;累了，等有时间再重构吧。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo生成静态文件</title>
      <link>http://moonsn.com/post/deploymenthugo/</link>
      <pubDate>Wed, 21 Oct 2015 19:54:25 +0800</pubDate>
      
      <guid>http://moonsn.com/post/deploymenthugo/</guid>
      <description>&lt;pre&gt;&lt;code&gt;$ sudo hugo server --watch --baseUrl=http://yoursite.org/ --appendPort=false
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang中的方法与接口</title>
      <link>http://moonsn.com/post/golang_3/</link>
      <pubDate>Wed, 21 Oct 2015 19:46:01 +0800</pubDate>
      
      <guid>http://moonsn.com/post/golang_3/</guid>
      <description>

&lt;h3 id=&#34;方法:1fe650016e84e1375349ba764bbab8d3&#34;&gt;方法&lt;/h3&gt;

&lt;p&gt;Go虽然没有类，但是可以在struct上定义方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math&amp;quot;
)

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func (v *Vertex) Show(what string) {
	fmt.Println(&amp;quot;show &amp;quot;, what)
}

func main() {
	v := &amp;amp;Vertex{3, 4}
	fmt.Println(v.Abs())
	v.Show(&amp;quot;me&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实，只要在你的包里声明的任何类型都可以定义方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math&amp;quot;
)

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f &amp;lt; 0 {
		return float64(-f)
	}
	return float64(f)
}

func main() {
	f := MyFloat(-math.Sqrt2)
	fmt.Println(f.Abs())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常方法是绑在指针上，这样避免了在传参的时候复制，也便于方法直接修改指针所指向的值。&lt;/p&gt;

&lt;h3 id=&#34;接口:1fe650016e84e1375349ba764bbab8d3&#34;&gt;接口&lt;/h3&gt;

&lt;p&gt;接口类型是一个包含&lt;code&gt;一组方法定义&lt;/code&gt;的集合。也就是接口里定义了一组方法。&lt;/p&gt;

&lt;p&gt;只要一个类型实现了这个接口了的方法，就能赋给这个接口类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math&amp;quot;
)

type Abser interface {
	Abs() float64
}

func main() {
	var a Abser
	f := MyFloat(-math.Sqrt2)
	v := Vertex{3, 4}

	a = f  // a MyFloat 实现了 Abser
	a = &amp;amp;v // a *Vertex 实现了 Abser

	// 下面一行，v 是一个 Vertex（而不是 *Vertex）
	// 所以没有实现 Abser。
	a = v

	fmt.Println(a.Abs())
}

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f &amp;lt; 0 {
		return float64(-f)
	}
	return float64(f)
}

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;exercise-stringer-go:1fe650016e84e1375349ba764bbab8d3&#34;&gt;exercise-stringer.go&lt;/h3&gt;

&lt;p&gt;这是对&lt;code&gt;fmt&lt;/code&gt;包里的&lt;code&gt;Stringer&lt;/code&gt;接口的使用，实现了他里面定义的&lt;code&gt;String() string&lt;/code&gt;方法.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Stringer&lt;/code&gt;是一个用&lt;code&gt;string&lt;/code&gt;描述自己的接口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type IPAddr [4]byte

// TODO: Add a &amp;quot;String() string&amp;quot; method to IPAddr.
func (x IPAddr) String() string {
	return fmt.Sprintf(&amp;quot;%d.%d.%d.%d&amp;quot;, x[0],x[1],x[2],x[3]);
}

func main() {
	addrs := map[string]IPAddr{
		&amp;quot;loopback&amp;quot;:  {127, 0, 0, 1},
		&amp;quot;googleDNS&amp;quot;: {8, 8, 8, 8},
	}
	for n, a := range addrs {
		fmt.Printf(&amp;quot;%v: %v\n&amp;quot;, n, a)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;error:1fe650016e84e1375349ba764bbab8d3&#34;&gt;Error&lt;/h3&gt;

&lt;p&gt;与fmt.Stringer类似，error类型是一个内建接口.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type error interface {
	Error() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常函数会返回一个 error 值，调用的它的代码应当判断这个错误是否等于 nil， 来进行错误处理。&lt;/p&gt;

&lt;p&gt;i, err := strconv.Atoi(&amp;ldquo;42&amp;rdquo;)
if err != nil {
    fmt.Printf(&amp;ldquo;couldn&amp;rsquo;t convert number: %v\n&amp;rdquo;, err)
}
fmt.Println(&amp;ldquo;Converted integer:&amp;ldquo;, i)
error 为 nil 时表示成功；非 nil 的 error 表示错误。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;exercise-errors.go&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type ErrNegativeSqrt float64

func (e ErrNegativeSqrt) Error() string {
	return fmt.Sprintf(&amp;quot;cannot Sqrt negative number: %v&amp;quot;, float64(e))
}

func Sqrt(x float64) (float64, error) {
	if x &amp;lt; 0 {
		return 0, ErrNegativeSqrt(x)
	}
	z := x
	for i := 0; i &amp;lt; 10; i++ {
		z = z - (z * z - x)/(2*z)
	}
	return z, nil
}



func main() {
	fmt.Println(Sqrt(2))
	fmt.Println(Sqrt(-2))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;exercise-rot-reader-go:1fe650016e84e1375349ba764bbab8d3&#34;&gt;exercise-rot-reader.go&lt;/h3&gt;

&lt;p&gt;这个开始没有读入到&lt;code&gt;io.Reader&lt;/code&gt;&amp;hellip;坑了半天&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;io&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strings&amp;quot;
)

type rot13Reader struct {
	r io.Reader
}

func (rot *rot13Reader) Read(bytes []byte) (int, error) {
	n, err := rot.r.Read(bytes)
	s := &amp;quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzNOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm&amp;quot;
	for index := range bytes {
		if !((bytes[index] &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; bytes[index] &amp;lt;=&#39;z&#39;) || (bytes[index] &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; bytes[index] &amp;lt;=&#39;Z&#39;)){
			continue
		}
		pos := strings.IndexByte(s, bytes[index])
		bytes[index] = s[pos + 26*2]
	}
	return n, err
}

func main() {
	s := strings.NewReader(&amp;quot;Lbh penpxrq gur pbqr!&amp;quot;)
	r := rot13Reader{s}
	io.Copy(os.Stdout, &amp;amp;r)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;web-servers:1fe650016e84e1375349ba764bbab8d3&#34;&gt;web servers&lt;/h3&gt;

&lt;p&gt;http包为任何实现了&lt;code&gt;http.Handler&lt;/code&gt;接口的值提供服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package http

type Handler interface {
    ServeHTTP(w ResponseWriter, r *Request)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;官网的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
)

type Hello struct{}

func (h Hello) ServeHTTP(
	w http.ResponseWriter,
	r *http.Request) {
	fmt.Fprint(w, &amp;quot;Hello!&amp;quot;)
}

func main() {
	var h Hello
	err := http.ListenAndServe(&amp;quot;localhost:4000&amp;quot;, h)
	if err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;exercise-http-handlers-go:1fe650016e84e1375349ba764bbab8d3&#34;&gt;exercise-http-handlers.go&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
		&amp;quot;fmt&amp;quot;
		&amp;quot;log&amp;quot;
		&amp;quot;net/http&amp;quot;
	   )

type String string

type Struct struct {
	Greeting	string
		Punct		string
		Who			string
}

func (str String) ServeHTTP(
		w http.ResponseWriter,
		r *http.Request) {
	fmt.Fprint(w, str)
}

func (stu *Struct) ServeHTTP(
		w http.ResponseWriter,
		r *http.Request) {
	fmt.Fprint(w,fmt.Sprintln(stu.Greeting, stu.Punct, stu.Who))
}

func main() {
	// your http.Handle calls here
	http.Handle(&amp;quot;/string&amp;quot;, String(&amp;quot;I&#39;m a frayed knot.&amp;quot;))
	http.Handle(&amp;quot;/struct&amp;quot;, &amp;amp;Struct{&amp;quot;Hello&amp;quot;, &amp;quot;:&amp;quot;, &amp;quot;Gophers!&amp;quot;})
	log.Fatal(http.ListenAndServe(&amp;quot;localhost:4000&amp;quot;, nil))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;excercise-images-go:1fe650016e84e1375349ba764bbab8d3&#34;&gt;excercise-images.go&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;golang.org/x/tour/pic&amp;quot;
import &amp;quot;image&amp;quot;
import &amp;quot;image/color&amp;quot;

type Image struct{
	w, h int
	colr uint8
}

func (IMG Image) ColorModel() color.Model {
	return color.RGBAModel
}

func (IMG Image) Bounds() image.Rectangle {
	return image.Rect(0, 0, 200, 200)
}

func (IMG Image) At(x, y int) color.Color {
	return color.RGBA{uint8(x), uint8(y), 255,255}
}

func main() {
	m := Image{100,100,200}
	pic.ShowImage(m)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang中的map和闭包</title>
      <link>http://moonsn.com/post/golang_2/</link>
      <pubDate>Wed, 21 Oct 2015 14:56:57 +0800</pubDate>
      
      <guid>http://moonsn.com/post/golang_2/</guid>
      <description>

&lt;h3 id=&#34;range:69277b731da08b89fa256107618093a3&#34;&gt;Range&lt;/h3&gt;

&lt;p&gt;range可以对slice或者map进行迭代循环&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
    for i, v := range pow {
        fmt.Printf(&amp;quot;2**%d = %d\n&amp;quot;, i, v)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;exercise-slices-go:69277b731da08b89fa256107618093a3&#34;&gt;exercise-slices.go&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;golang.org/x/tour/pic&amp;quot;

func Pic(dx, dy int) [][]uint8 {
    pic := make([][]uint8, dy);
    for y := range pic {
        pic[y] = make([]uint8, dx)
        for x := range pic[y] {
            pic[y][x] = uint8((x+y)/2)
        }
    }
    return pic
}

func main() {
    pic.Show(Pic)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;map:69277b731da08b89fa256107618093a3&#34;&gt;map&lt;/h3&gt;

&lt;p&gt;map在使用前必须用&lt;code&gt;make&lt;/code&gt;来创建.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
    Lat, Long float64
}

var m map[string]Vertex

func main() {
    m = make(map[string]Vertex)
    m[&amp;quot;Bell Labs&amp;quot;] = Vertex{
        40.68433, -74.39967,
    }
    fmt.Println(m[&amp;quot;Bell Labs&amp;quot;])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
    Lat, Long float64
}

var m = map[string]Vertex{
    &amp;quot;Bell Labs&amp;quot;: Vertex{
        40.68433, -74.39967,
    },
    &amp;quot;Google&amp;quot;: Vertex{
        37.42202, -122.08408,
    },
}

func main() {
    fmt.Println(m)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插入或修改一个元素：&lt;code&gt;m[key] = elem&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;获取元素：&lt;code&gt;elem = m[key]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;删除元素：&lt;code&gt;delete(m, key)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;通过双赋值检查某个键是否存在：&lt;code&gt;elem, ok = m[key]&lt;/code&gt;
存在ok为true&lt;/p&gt;

&lt;h3 id=&#34;exercise-map-go:69277b731da08b89fa256107618093a3&#34;&gt;exercise-map.go&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;code.google.com/p/go-tour/wc&amp;quot;
    &amp;quot;strings&amp;quot;
)

func WordCount(s string) map[string]int {
    word_list := strings.Fields(s)
    m := make(map[string]int)
    for _, value := range word_list {
        m[value] ++
    }
    return m
}

func main() {
    wc.Test(WordCount)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;func-value:69277b731da08b89fa256107618093a3&#34;&gt;func value&lt;/h3&gt;

&lt;p&gt;函数也可以当做值赋给变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;math&amp;quot;
)

func main() {
    hypot := func(x, y float64) float64 {
        return math.Sqrt(x*x + y*y)
    }

    fmt.Println(hypot(3, 4))
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;闭包:69277b731da08b89fa256107618093a3&#34;&gt;闭包&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func adder() func(int) int {
    sum := 0
    return func(x int) int {
        sum += x
        return sum
    }
}

func main() {
    pos, neg := adder(), adder()
    for i := 0; i &amp;lt; 10; i++ {
        fmt.Println(
            pos(i),
            neg(-2*i),
        )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用闭包输出斐波那契数列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

// fibonacci 函数会返回一个返回 int 的函数。
func fibonacci() func() int {
    a, b := 0, 1
    return func() int {
        a = a + b
        a, b = b, a
        return a
    }
}

func main() {
    f := fibonacci()
    for i := 0; i &amp;lt; 10; i++ {
        fmt.Println(f())
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang中的Slice</title>
      <link>http://moonsn.com/post/golangslice/</link>
      <pubDate>Wed, 21 Oct 2015 14:17:10 +0800</pubDate>
      
      <guid>http://moonsn.com/post/golangslice/</guid>
      <description>

&lt;h3 id=&#34;what:90cfd4505499368a99e1f321bbb29b12&#34;&gt;What?&lt;/h3&gt;

&lt;p&gt;Slice(切片)可以看做是包含三个属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;指向数组的指针&lt;/li&gt;
&lt;li&gt;切片的长度&lt;/li&gt;
&lt;li&gt;切片的容量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用[]来访问切片，len函数可以返回切片的长度，cap函数可以返回切片的容量。&lt;/p&gt;

&lt;h3 id=&#34;how-to-creat-it:90cfd4505499368a99e1f321bbb29b12&#34;&gt;How To Creat It?&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;s := make([]int, 10) // len(s) = 10, cap(s) = 10
or
s := []int{1, 2, 3, 4, 5} //len(s) = 5, cap(s) = 5
or 
var a [10]int
s := a[1:5] //len(s) = 4, cap(s) = 10, same as make([]int, 4, 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当数组a改变是，切片也会变。切片的操作也会影响数组&lt;/p&gt;

&lt;h3 id=&#34;some-else:90cfd4505499368a99e1f321bbb29b12&#34;&gt;Some else!&lt;/h3&gt;

&lt;p&gt;append函数可以在slice后面加元素。这这时会为slice重新分配空间。如果之前是指向某个数组的，那么，append会使关系失效。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    var a = [...]int{1,2,3,4,5}
    z := a[1:4]
    fmt.Println(a)//[1 2 3 4 5]
    fmt.Println(z)//[2 3 4]
    z[2] = 3
    fmt.Println(a)//[1 2 3 3 5]
    fmt.Println(z)//[2 3 3]
    z = append(z,6,7)
    fmt.Println(a)//[1 2 3 3 5]
    fmt.Println(z)//[2 3 3 6 7]
    a[0] = 10
    fmt.Println(a)//[10 2 3 3 5]
    fmt.Println(z)//[2 3 3 6 7]
    z[0] = 20
    fmt.Println(a)//[10 2 3 3 5]
    fmt.Println(z)//[20 3 3 6 7]
    s := a[0:3]
    z = append(z, s...)
    fmt.Println(z)//[20 3 3 6 7 10 2 3]
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang的结构，基本类型及语法</title>
      <link>http://moonsn.com/post/aboutgolang/</link>
      <pubDate>Wed, 21 Oct 2015 11:00:08 +0800</pubDate>
      
      <guid>http://moonsn.com/post/aboutgolang/</guid>
      <description>

&lt;p&gt;golang需要指定一个工作目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;▾ workspace
    ▾ src (用于存放go源码)
    ▾ pkg (放包)
    ▾ bin (编译出来的东西会放到这里)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go源码文件的第一行必须是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你import一个package的时候，他会解析出目录最后一个元素作为包名，以便在代码中使用。&lt;/p&gt;

&lt;h3 id=&#34;testing:e8844f493f37509013ac5e563f59eb18&#34;&gt;Testing&lt;/h3&gt;

&lt;p&gt;go有一个轻量级的测试框架。go test 命令和testing 包&lt;/p&gt;

&lt;p&gt;你只需要建立一个以_test.go结尾的文件,go test 会运行里面的所有TestXXX函数（这些函数是参数是 &lt;code&gt;(t *testing.T)&lt;/code&gt;)，如果函数调用了&lt;code&gt;t.Error&lt;/code&gt;或&lt;code&gt;t.Fail&lt;/code&gt;，就认为测试失败。&lt;/p&gt;

&lt;p&gt;我们给stringutil添加一个测试:&lt;/p&gt;

&lt;h4 id=&#34;gopath-src-github-com-moonsn-stringutil-reverse-test-go:e8844f493f37509013ac5e563f59eb18&#34;&gt;$GOPATH/src/github.com/moonsn/stringutil/reverse_test.go&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package stringutil

import &amp;quot;testing&amp;quot;

func TestReverse(t *testing.T) {
    cases := []struct {
        in, want string
    }{
        {&amp;quot;Hello, world&amp;quot;, &amp;quot;dlrow ,olleH&amp;quot;},
        {&amp;quot;Hello, 世界&amp;quot;, &amp;quot;界世 ,olleH&amp;quot;}
        {&amp;quot;&amp;quot;,&amp;quot;&amp;quot;}
    }
    for _, c := range cases {
        got := Reverse(c.in)
        if got != c.want {
            t.Errorf(&amp;quot;Reverse(%q) == %q, want %q&amp;quot;, c.in, got, c.want)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行test&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go test
ok      github.com/user/stringutil 0.165s
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;remote-package:e8844f493f37509013ac5e563f59eb18&#34;&gt;Remote Package&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/golang/example/hello
$ $GOPATH/bin/hello
Hello, Go example!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;go get&lt;/code&gt;会自动fetch,build,insatll&lt;/p&gt;

&lt;h3 id=&#34;func:e8844f493f37509013ac5e563f59eb18&#34;&gt;func&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func swap(x, y string) (string, string) {
    return y, x
}

func main() {
    a, b := swap(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;)
    fmt.Println(a, b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;函数参数类型在变量名之后，多个相同的连续类型可以只写最后一个。&lt;/li&gt;
&lt;li&gt;返回值类型写在参数列表之后。&lt;/li&gt;
&lt;li&gt;函数可以返回任意多个返回值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;var:e8844f493f37509013ac5e563f59eb18&#34;&gt;var&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

var i, j int = 1, 2

func main() {
    var c, python, java = true, false, &amp;quot;no!&amp;quot;
    k := 3
    fmt.Println(i, j, c, python, java)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;var 语句定义了一个变量的列表；跟函数的参数列表一样，类型在后面。&lt;/li&gt;
&lt;li&gt;就像在这个例子中看到的一样， var 语句可以定义在包或函数级别。&lt;/li&gt;
&lt;li&gt;变量定义可以包含初始值，每个变量对应一个。&lt;/li&gt;
&lt;li&gt;如果初始化是使用表达式，则可以省略类型；变量从初始值中获得类型。&lt;/li&gt;
&lt;li&gt;在函数中， := 简洁赋值语句在明确类型的地方，可以用于替代 var 定义。&lt;/li&gt;
&lt;li&gt;函数外的每个语句都必须以关键字开始（ var 、 func 、等等）， := 结构不能使用在函数外。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;基本类型:e8844f493f37509013ac5e563f59eb18&#34;&gt;基本类型&lt;/h3&gt;

&lt;p&gt;Go 的基本类型有Basic types&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8 的别名

rune // int32 的别名
     // 代表一个Unicode码

float32 float64

complex64 complex128
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;math/cmplx&amp;quot;
)

//可以像这样定义变量
var (
    ToBe   bool       = false
    MaxInt uint64     = 1&amp;lt;&amp;lt;64 - 1
    z      complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
    const f = &amp;quot;%T(%v)\n&amp;quot; //T 类型 v变量
    fmt.Printf(f, ToBe, ToBe)
    fmt.Printf(f, MaxInt, MaxInt)
    fmt.Printf(f, z, z)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;for:e8844f493f37509013ac5e563f59eb18&#34;&gt;for&lt;/h3&gt;

&lt;p&gt;Go 只有一种循环结构—— for 循环。&lt;/p&gt;

&lt;p&gt;基本的 for 循环除了没有了 ( ) 之外（甚至强制不能使用它们），看起来跟 C 或者 Java 中做的一样，而 { } 是必须的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    sum := 0
    for i := 0; i &amp;lt; 10; i++ {
        sum += i
    }
    fmt.Println(sum)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;where:e8844f493f37509013ac5e563f59eb18&#34;&gt;where ?&lt;/h3&gt;

&lt;p&gt;like this!!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    sum := 1
    for sum &amp;lt; 1000 { //while(sum&amp;lt;1000)
        sum += sum
    }
    fmt.Println(sum)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;那么全省略的话:e8844f493f37509013ac5e563f59eb18&#34;&gt;那么全省略的话？？&lt;/h3&gt;

&lt;p&gt;当然是无限循环了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

func main() {
    for {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;if:e8844f493f37509013ac5e563f59eb18&#34;&gt;if&lt;/h3&gt;

&lt;p&gt;和for一样，省略了括号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;math&amp;quot;
)

func sqrt(x float64) string {
    if x &amp;lt; 0 {
        return sqrt(-x) + &amp;quot;i&amp;quot;
    }
    return fmt.Sprint(math.Sqrt(x))
}

func main() {
    fmt.Println(sqrt(2), sqrt(-4))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一样的地方还有：可以在条件前面定义一个局部变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;math&amp;quot;
)

func pow(x, n, lim float64) float64 {
    if v := math.Pow(x, n); v &amp;lt; lim {
        return v
    }
    return v;
}

func main() {
    fmt.Println(
        pow(3, 2, 10),
        pow(3, 3, 20),
    )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;defer:e8844f493f37509013ac5e563f59eb18&#34;&gt;defer&lt;/h3&gt;

&lt;p&gt;defer会延迟函数的执行，指导上层函数返回。（defer 的函数会执行并要入一个栈中）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    fmt.Println(&amp;quot;counting&amp;quot;)

    for i := 0; i &amp;lt; 10; i++ {
        defer fmt.Println(i)
    }

    fmt.Println(&amp;quot;done&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;指针:e8844f493f37509013ac5e563f59eb18&#34;&gt;指针&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var p *int;
i := 42
p = &amp;amp;i
fmt.Println(*p);//42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用法同c语言，但是没有指针运算。&lt;/p&gt;

&lt;h3 id=&#34;结构体:e8844f493f37509013ac5e563f59eb18&#34;&gt;结构体&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
    X int
    Y int
}

func main() {
    v := Vertex{1, 2}
    p := &amp;amp;v
    p.X = 1e9
    fmt.Println(v)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;数组:e8844f493f37509013ac5e563f59eb18&#34;&gt;数组&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var arr [10]int
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>为Hugo的文章页创建模板</title>
      <link>http://moonsn.com/post/hugo-single/</link>
      <pubDate>Tue, 20 Oct 2015 22:29:32 +0800</pubDate>
      
      <guid>http://moonsn.com/post/hugo-single/</guid>
      <description>

&lt;p&gt;single 是最主要的视图，Hugo会为每个Markdown文件提供一个single模板来渲染。&lt;/p&gt;

&lt;h2 id=&#34;会用哪个模板来渲染呢:e6d3cde5b499b420f687e97496609c42&#34;&gt;会用哪个模板来渲染呢？&lt;/h2&gt;

&lt;p&gt;Hugo 用一系列的规则来推测应该用哪个模板类渲染一个页面。&lt;/p&gt;

&lt;p&gt;Hugo 选择模板的优先级如下表。如果一个文件不存在，那么下一个会被使用。这使得你可以为更多的页面设计模板。但多数情况下,列表最后的&lt;code&gt;_default&lt;/code&gt; 文件就够啦。&lt;/p&gt;

&lt;p&gt;用户可以在&lt;code&gt;front-matter&lt;/code&gt;部分定义&lt;code&gt;type&lt;/code&gt; 和&lt;code&gt;layout&lt;/code&gt;指定用哪个模板渲染。&lt;code&gt;Section&lt;/code&gt;是由md文件所在的位置来确定的。当然，如果你指定了&lt;code&gt;type&lt;/code&gt;，那么还是以&lt;code&gt;type&lt;/code&gt;为准。&lt;/p&gt;

&lt;h3 id=&#34;single:e6d3cde5b499b420f687e97496609c42&#34;&gt;Single&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;/layouts/TYPE-or-SECTION/LAYOUT.html&lt;/li&gt;
&lt;li&gt;/layouts/TYPE-or-SECTION/single.html&lt;/li&gt;
&lt;li&gt;/layouts/_default/single.html&lt;/li&gt;
&lt;li&gt;/themes/THEME/layouts/TYPE-or-SECTION/LAYOUT.html&lt;/li&gt;
&lt;li&gt;/themes/THEME/layouts/TYPE-or-SECTION/single.html&lt;/li&gt;
&lt;li&gt;/themes/THEME/layouts/_default/single.html&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;模板示例:e6d3cde5b499b420f687e97496609c42&#34;&gt;模板示例&lt;/h2&gt;

&lt;p&gt;md页面是&amp;rsquo;page&amp;rsquo;类型的，在他的模板中可以使用所有&lt;code&gt;page variables&lt;/code&gt;和&lt;code&gt;site variable&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;下面我们将造着默认的模板，创建两个不同的类型的模板。&lt;/p&gt;

&lt;p&gt;默认模板会在没有指定type是使用，他的工作原理和其他模板是一样的，但是他必须在&amp;rdquo;_default&amp;rdquo;目录下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;▾ layouts/
	▾ _default/
		single.html
	▾ post/
		single.html
	▾ project/
		single.html
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;post-single-html:e6d3cde5b499b420f687e97496609c42&#34;&gt;post/single.html&lt;/h3&gt;

&lt;p&gt;这个模板是&lt;a href=&#34;http://spf13.com&#34;&gt;spf13.com&lt;/a&gt;在使用的模板。他用到了&lt;code&gt;partial templates&lt;/code&gt;(也就是模板引用)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ partial &amp;quot;header.html&amp;quot; . }}
{{ partial &amp;quot;subheader.html&amp;quot; . }}
{{ $baseurl := .Site.BaseURL }}

&amp;lt;section id=&amp;quot;main&amp;quot;&amp;gt;
  &amp;lt;h1 id=&amp;quot;title&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/h1&amp;gt;
  &amp;lt;div&amp;gt;
        &amp;lt;article id=&amp;quot;content&amp;quot;&amp;gt;
           {{ .Content }}
        &amp;lt;/article&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/section&amp;gt;

&amp;lt;aside id=&amp;quot;meta&amp;quot;&amp;gt;
    &amp;lt;div&amp;gt;
    &amp;lt;section&amp;gt;
      &amp;lt;h4 id=&amp;quot;date&amp;quot;&amp;gt; {{ .Date.Format &amp;quot;Mon Jan 2, 2006&amp;quot; }} &amp;lt;/h4&amp;gt;
      &amp;lt;h5 id=&amp;quot;wc&amp;quot;&amp;gt; {{ .FuzzyWordCount }} Words &amp;lt;/h5&amp;gt;
    &amp;lt;/section&amp;gt;
    &amp;lt;ul id=&amp;quot;categories&amp;quot;&amp;gt;
      {{ range .Params.topics }}
        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{{ $baseurl }}/topics/{{ . | urlize }}&amp;quot;&amp;gt;{{ . }}&amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt;
      {{ end }}
    &amp;lt;/ul&amp;gt;
    &amp;lt;ul id=&amp;quot;tags&amp;quot;&amp;gt;
      {{ range .Params.tags }}
        &amp;lt;li&amp;gt; &amp;lt;a href=&amp;quot;{{ $baseurl }}/tags/{{ . | urlize }}&amp;quot;&amp;gt;{{ . }}&amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt;
      {{ end }}
    &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;
        {{ if .Prev }}
          &amp;lt;a class=&amp;quot;previous&amp;quot; href=&amp;quot;{{.Prev.Permalink}}&amp;quot;&amp;gt; {{.Prev.Title}}&amp;lt;/a&amp;gt;
        {{ end }}
        {{ if .Next }}
          &amp;lt;a class=&amp;quot;next&amp;quot; href=&amp;quot;{{.Next.Permalink}}&amp;quot;&amp;gt; {{.Next.Title}}&amp;lt;/a&amp;gt;
        {{ end }}
    &amp;lt;/div&amp;gt;
&amp;lt;/aside&amp;gt;

{{ partial &amp;quot;disqus.html&amp;quot; . }}
{{ partial &amp;quot;footer.html&amp;quot; . }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;project-single-html:e6d3cde5b499b420f687e97496609c42&#34;&gt;project/single.html&lt;/h3&gt;

&lt;p&gt;这个模板是&lt;a href=&#34;http://spf13.com&#34;&gt;spf13.com&lt;/a&gt;在使用的模板。他用到了&lt;code&gt;partial templates&lt;/code&gt;(也就是模板引用)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ partial &amp;quot;header.html&amp;quot; . }}
{{ partial &amp;quot;subheader.html&amp;quot; . }}
{{ $baseurl := .Site.BaseURL }}

&amp;lt;section id=&amp;quot;main&amp;quot;&amp;gt;
  &amp;lt;h1 id=&amp;quot;title&amp;quot;&amp;gt;{{ .Title }}&amp;lt;/h1&amp;gt;
  &amp;lt;div&amp;gt;
        &amp;lt;article id=&amp;quot;content&amp;quot;&amp;gt;
           {{ .Content }}
        &amp;lt;/article&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/section&amp;gt;

&amp;lt;aside id=&amp;quot;meta&amp;quot;&amp;gt;
    &amp;lt;div&amp;gt;
    &amp;lt;section&amp;gt;
      &amp;lt;h4 id=&amp;quot;date&amp;quot;&amp;gt; {{ .Date.Format &amp;quot;Mon Jan 2, 2006&amp;quot; }} &amp;lt;/h4&amp;gt;
      &amp;lt;h5 id=&amp;quot;wc&amp;quot;&amp;gt; {{ .FuzzyWordCount }} Words &amp;lt;/h5&amp;gt;
    &amp;lt;/section&amp;gt;
    &amp;lt;ul id=&amp;quot;categories&amp;quot;&amp;gt;
      {{ range .Params.topics }}
      &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{{ $baseurl }}/topics/{{ . | urlize }}&amp;quot;&amp;gt;{{ . }}&amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt;
      {{ end }}
    &amp;lt;/ul&amp;gt;
    &amp;lt;ul id=&amp;quot;tags&amp;quot;&amp;gt;
      {{ range .Params.tags }}
        &amp;lt;li&amp;gt; &amp;lt;a href=&amp;quot;{{ $baseurl }}/tags/{{ . | urlize }}&amp;quot;&amp;gt;{{ . }}&amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt;
      {{ end }}
    &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/aside&amp;gt;

{{if isset .Params &amp;quot;project_url&amp;quot; }}
&amp;lt;div id=&amp;quot;ribbon&amp;quot;&amp;gt;
    &amp;lt;a href=&amp;quot;{{ index .Params &amp;quot;project_url&amp;quot; }}&amp;quot; rel=&amp;quot;me&amp;quot;&amp;gt;Fork me on GitHub&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
{{ end }}

{{ partial &amp;quot;footer.html&amp;quot; . }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，上面的project/single.html中使用了只对这个模板起作用的附加参数。他不需要提前定义，如果这个参数在&lt;code&gt;fornt-matter&lt;/code&gt;中定义了的话就能在模板中使用他。&lt;/p&gt;

&lt;p&gt;当然，你可以用&lt;code&gt;content archetypes&lt;/code&gt;来快速生成这类模板对应的主题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>about</title>
      <link>http://moonsn.com/about/</link>
      <pubDate>Tue, 20 Oct 2015 17:55:24 +0800</pubDate>
      
      <guid>http://moonsn.com/about/</guid>
      <description>&lt;p&gt;哈哈哈，上当啦！账号都在博客里呢~&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>